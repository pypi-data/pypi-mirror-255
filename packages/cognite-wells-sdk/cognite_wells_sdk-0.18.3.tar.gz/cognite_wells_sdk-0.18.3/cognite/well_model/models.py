# generated by datamodel-codegen:
#   filename:  openapi.yaml

from __future__ import annotations

from datetime import date
from enum import Enum
from typing import Any, List, Optional

from pydantic import Field

from cognite.well_model.base_model import WellsBaseModel


class SummaryCount(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    property: str
    count: Optional[int] = None


class CursorAndLimit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1,
        le=1000,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class DateRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: Optional[date] = None
    max: Optional[date] = None


class DistanceUnitEnum(str, Enum):
    meter = "meter"
    foot = "foot"
    inch = "inch"
    yard = "yard"


class AngleUnitEnum(str, Enum):
    degree = "degree"
    radian = "radian"


class DurationUnitEnum(str, Enum):
    millisecond = "millisecond"
    second = "second"
    minute = "minute"
    hour = "hour"
    day = "day"


class DepthIndexTypeEnum(str, Enum):
    measured_depth = "measured depth"
    true_vertical_depth = "true vertical depth"


class DurationRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    unit: DurationUnitEnum
    min: Optional[float] = None
    max: Optional[float] = None


class PhaseEnum(str, Enum):
    proposed = "proposed"
    planned = "planned"
    actual = "actual"


class Identifier(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: Optional[str] = Field(None, alias="matchingId", description="Matching id of a well or a wellbore.")
    asset_external_id: Optional[str] = Field(
        None, alias="assetExternalId", description="Asset id of a well or a wellbore"
    )


class IdentifierItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Identifier] = Field(..., max_items=1000, min_items=1)
    ignore_unknown_ids: Optional[bool] = Field(
        False, alias="ignoreUnknownIds", description="Ignore external IDs and matching IDs that are not found."
    )


class SequenceExternalId(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sequence_external_id: str = Field(
        ..., alias="sequenceExternalId", description="An external ID for a sequence in CDF."
    )


class EventExternalId(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    event_external_id: str = Field(..., alias="eventExternalId")


class ExternalIdTypeEnum(str, Enum):
    asset = "asset"
    event = "event"
    file = "file"
    sequence = "sequence"
    timeseries = "timeseries"
    relationship = "relationship"


class SummaryItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[SummaryCount]


class WellPropertiesEnum(str, Enum):
    region = "region"
    country = "country"
    block = "block"
    field = "field"
    quadrant = "quadrant"
    operator = "operator"


class WellPropertiesSummaryRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellPropertiesEnum]


class WellPropertiesSummaryRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    region: Optional[str] = None
    country: Optional[str] = None
    block: Optional[str] = None
    field: Optional[str] = None
    quadrant: Optional[str] = None
    operator: Optional[str] = None
    wells_count: int = Field(..., alias="wellsCount")


class PropertyFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    is_set: Optional[bool] = Field(None, alias="isSet")
    one_of: Optional[List[str]] = Field(None, alias="oneOf")


class SourceExternalId(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    external_id: str = Field(..., alias="externalId", description="An identifier for a CDF resource.")
    type: ExternalIdTypeEnum
    source_name: str = Field(
        ..., alias="sourceName", description="Name of the source this external ID belongs to.", example="EDM"
    )


class WellMergeRules(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: List[str]
    description: List[str]
    country: List[str]
    quadrant: List[str]
    region: List[str]
    block: List[str]
    field: List[str]
    operator: List[str]
    spud_date: List[str] = Field(..., alias="spudDate")
    license: List[str]
    well_type: List[str] = Field(..., alias="wellType")
    water_depth: List[str] = Field(..., alias="waterDepth")
    wellhead: List[str]


class Wellhead(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    x: float = Field(..., example=10.74609)
    y: float = Field(..., example=59.91273)
    crs: str = Field(..., description="The coordinate reference systems of the wellhead.", example="EPSG:4326")


class WellboreMergeRules(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: List[str]
    description: List[str]
    datum: List[str]
    parents: List[str]
    well_tops: List[str] = Field(..., alias="wellTops")
    hole_sections: Optional[List[str]] = Field(None, alias="holeSections")
    trajectories: Optional[List[str]] = None
    casings: Optional[List[str]] = None
    total_drilling_days: Optional[List[str]] = Field(None, alias="totalDrillingDays")
    kickoff_measured_depth: Optional[List[str]] = Field(None, alias="kickoffMeasuredDepth")


class DeleteEventSources(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[EventExternalId] = Field(..., max_items=1000, min_items=1)


class NptAggregateEnum(str, Enum):
    npt_code = "npt code"
    npt_code_detail = "npt code detail"


class NptAggregateRequestFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_ids: List[Identifier] = Field(..., alias="wellboreIds", max_items=1000, min_items=1)


class ContainsAllOrAny(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_all: Optional[List[str]] = Field(None, alias="containsAll", description="match on all of the strings")
    contains_any: Optional[List[str]] = Field(None, alias="containsAny", description="match on any of the strings")


class ContainsAllOrAnyInt(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_all: Optional[List[int]] = Field(None, alias="containsAll", description="match on all of the strings")
    contains_any: Optional[List[int]] = Field(None, alias="containsAny", description="match on any of the strings")


class NdsAggregateEnum(str, Enum):
    severity = "severity"
    probability = "probability"
    risk_type = "risk type"
    subtype = "subtype"


class NdsAggregateRequestFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_ids: List[Identifier] = Field(..., alias="wellboreIds", max_items=1000, min_items=1)


class NdsAggregateRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    count: int = Field(..., description="Number of NPT events that matches this group")
    severity: Optional[int] = None
    probability: Optional[int] = None
    risk_type: Optional[str] = Field(None, alias="riskType")
    subtype: Optional[str] = None


class DepthMeasurementColumn(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_type: str = Field(..., alias="measurementType")
    column_external_id: str = Field(
        ..., alias="columnExternalId", description="External ID of the sequence column", example="GAMMA_RAY"
    )
    unit: str = Field(..., description="Unit for the measurement type", example="gApi")
    description: Optional[str] = None


class MeasurementType(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    type: Optional[str] = None


class TimeMeasurementColumn(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    timeseries_external_id: str = Field(
        ...,
        alias="timeseriesExternalId",
        description="The CDF external ID of the timeseries containing the measurement data",
    )
    unit: str
    measurement_type: str = Field(..., alias="measurementType")


class TimeMeasurementFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_types: Optional[List[str]] = Field(None, alias="measurementTypes")
    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds", max_items=1000, min_items=1)


class TrajectoryIngestionRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measured_depth: float = Field(..., alias="measuredDepth")
    inclination: float
    azimuth: float
    dogleg_severity: Optional[float] = Field(None, alias="doglegSeverity")


class TrajectoryFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds", max_items=1000, min_items=1)
    is_definitive: Optional[bool] = Field(
        None, alias="isDefinitive", description="If set to true, you will only retrieve definitive trajectories."
    )


class TrajectoryFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[TrajectoryFilter] = None


class DeleteSequenceSources(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[SequenceExternalId] = Field(..., max_items=1000, min_items=1)


class Chronostratigraphic(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    age: Optional[str] = Field(
        None, description="Geochronologic age/stage. Examples: maastrichtian, danian, lutetian.", example="kasimovian"
    )
    sub_epoch: Optional[str] = Field(
        None,
        alias="subEpoch",
        description="Geochronologic sub epoch used in parts of north america. Example: upper pennsylvanian.",
        example="upper pennsylvanian",
    )
    epoch: Optional[str] = Field(
        None, description="Geochronologic epoch. Examples: miocene, eocene, upper jurassic.", example="pennsylvanian"
    )
    period: Optional[str] = Field(
        None, description="Geochronologic period. Examples. neogene, cretaceous, jurassic.", example="carboniferous"
    )
    era: Optional[str] = Field(
        None, description="Geochronologic era: Examples: Cenozoic, Mesozoic.", example="paleozoic"
    )


class LithostratigraphicLevelEnum(str, Enum):
    bed = "bed"
    member = "member"
    formation = "formation"
    group = "group"


class Lithostratigraphic(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    level: LithostratigraphicLevelEnum


class WellTopSurfaceDepth(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measured_depth: float = Field(..., alias="measuredDepth")
    true_vertical_depth: Optional[float] = Field(None, alias="trueVerticalDepth")


class WellTopsFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_ids: List[Identifier] = Field(
        ..., alias="wellboreIds", description="Limit results to following wellbores", max_items=1000, min_items=1
    )
    is_definitive: Optional[bool] = Field(
        None,
        alias="isDefinitive",
        description="Specifies if the query is to return only definitive or not. If value is not set, then all well tops are returned.",
    )


class DistanceRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    unit: DistanceUnitEnum
    min: Optional[float] = Field(None, description="Lower bound of the range.")
    max: Optional[float] = Field(None, description="Upper bound of the range.")


class AngleRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    unit: AngleUnitEnum
    min: Optional[float] = None
    max: Optional[float] = None


class TimeRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: Optional[int] = Field(None, description="Epoch timestamp in milliseconds when time range started.", example=1)
    max: Optional[int] = Field(None, description="Epoch timestamp in milliseconds when time range ended.", example=1)


class TrajectoryDataRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sequence_external_id: str = Field(..., alias="sequenceExternalId")
    measured_depth: Optional[DistanceRange] = Field(None, alias="measuredDepth")
    true_vertical_depth: Optional[DistanceRange] = Field(None, alias="trueVerticalDepth")


class TrajectoryDataRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    true_vertical_depth: float = Field(..., alias="trueVerticalDepth")
    measured_depth: float = Field(..., alias="measuredDepth")
    northing: Optional[float] = None
    easting: Optional[float] = None
    north_offset: float = Field(..., alias="northOffset")
    east_offset: float = Field(..., alias="eastOffset")
    azimuth: float
    inclination: float
    dogleg_severity: float = Field(..., alias="doglegSeverity")
    equivalent_departure: float = Field(..., alias="equivalentDeparture")


class WeightUnitEnum(str, Enum):
    kilogram = "kilogram"
    pound = "pound"


class CasingFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds", max_items=1000, min_items=1)
    is_definitive: Optional[bool] = Field(
        None,
        alias="isDefinitive",
        description="Specifies if the query is to return only definitive or not. If value is not set, then all casings are returned.",
    )


class CasingFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[CasingFilter] = None


class WellSearch(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    query: str = Field(..., description="Fuzzy search on well name")


class WellFilterAggregatesEnum(str, Enum):
    count = "count"


class WellByIdsRequest(IdentifierItems):
    class Config:
        allow_population_by_field_name = True

    output_crs: Optional[str] = Field(
        None,
        alias="outputCrs",
        description="Specifies coordinate reference system (CRS) for output\ncoordinates. The `outputCrs` must be on the format `EPSG:####` or `ESRI:####`.\nIf not specified, the CRS will be the one the wells were ingested with.\n",
        example="EPSG:4326",
    )


class GeometryTypeEnum(str, Enum):
    wkt = "WKT"
    geo_json = "GeoJSON"


class WellTopFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    exists: Optional[bool] = Field(
        True,
        description="Set to false to filter on wellbores that do not pass through the specified surfaces. If no surfaces are specified then only wellbores that are not associated with any surface are returned.\n",
    )
    surface_names: Optional[ContainsAllOrAny] = Field(None, alias="surfaceNames")


class ContainsAllOrAnyMeasurementType(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_any: List[str] = Field(..., alias="containsAny")


class WellCasingFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    exists: Optional[bool] = Field(
        True, description="Set to false to filter on wellbores that do not have any casings."
    )


class WellDataAvailabilityFilterEnum(str, Enum):
    npt = "npt"
    nds = "nds"
    trajectories = "trajectories"
    depth_measurements = "depthMeasurements"
    casings = "casings"
    hole_sections = "holeSections"
    time_measurements = "timeMeasurements"
    well_tops = "wellTops"


class WellDataAvailabilityFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    contains_any: List[WellDataAvailabilityFilterEnum] = Field(
        ..., alias="containsAny", example=["npt", "nds", "casings", "trajectories"], min_items=1
    )


class WellSourcesFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sources: Optional[List[str]] = Field(None, example=["EDM", "Sitecom"])


class WellSourcesFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[WellSourcesFilter] = None


class WellboreSourcesFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sources: Optional[List[str]] = Field(None, example=["EDM", "Sitecom"])


class WellboreSourcesFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[WellboreSourcesFilter] = None


class DepthMeasurementWellTopsFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    surface_names: Optional[ContainsAllOrAny] = Field(
        None,
        alias="surfaceNames",
        description="A list of well top surfaces names. Alpha version, only containsAny is supported.",
    )


class DistanceUnit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    unit: DistanceUnitEnum
    factor: Optional[float] = Field(1.0, example=1.0)


class DepthMeasurementRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    row_number: int = Field(..., alias="rowNumber", description="The row number for this row", example=1, ge=0)
    depth: float
    values: List[Any] = Field(
        ...,
        description="List of values in order defined in the columns field (Number of items must match. Null is accepted for missing values. String values must be no longer than 256 characters)",
    )


class DepthMeasurementValueTypeEnum(str, Enum):
    string = "string"
    double = "double"
    long = "long"


class AssetSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    asset_external_id: str = Field(..., alias="assetExternalId", description="Asset external ID.")
    source_name: str = Field(
        ..., alias="sourceName", description="Name of the source this asset external ID belongs to.", example="EDM"
    )


class EventSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    event_external_id: str = Field(..., alias="eventExternalId")
    source_name: str = Field(..., alias="sourceName")


class SequenceSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sequence_external_id: str = Field(..., alias="sequenceExternalId", description="An external ID of a CDF sequence.")
    source_name: str = Field(..., alias="sourceName", description="Name of the source.", example="EDM")


class ExternalIdSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    external_id: str = Field(..., alias="externalId", description="An external ID of a resource.")


class Error(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    code: int = Field(..., description="HTTP status code.", example=401)
    message: str = Field(..., description="Error message.", example="Could not authenticate.")


class ErrorResponse(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    error: Error = Field(..., description="Cognite API error.")


class Source(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., description="The name and identifier of the source.", example="EDM")
    description: Optional[str] = Field(None, description="The description of the source.")


class MnemonicSearch(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    mnemonics: List[str] = Field(
        ..., description="List of mnemonics to search for.", example=["DEPT", "GR", "TENS", "CVEL", "INCL"]
    )


class MnemonicMatchTool(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    code: str
    description: Optional[str] = None


class MeasurementTypeFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_types: List[str] = Field(..., alias="measurementTypes", max_items=1000, min_items=1)


class MeasurementTypeDetails(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    property: str
    path: str
    description: str
    primary_quantity_class: str = Field(..., alias="primaryQuantityClass")


class RigOperation(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external ID of the wellbore where the operation took place. The asset must have been ingested as a wellbore with the same source name as this Rig Operation.",
        max_length=255,
    )
    wellbore_matching_id: str = Field(
        ...,
        alias="wellboreMatchingId",
        description="The matching id of the wellbore related to operation.",
        max_length=255,
    )
    source: SourceExternalId = Field(..., description="The source external ID in CDF.")
    rig_name: str = Field(..., alias="rigName", description="The name of the rig.", max_length=255)
    start_time: Optional[int] = Field(
        None,
        alias="startTime",
        description="Epoch timestamp in milliseconds for when the operation started.",
        example=1,
        ge=0,
    )
    end_time: Optional[int] = Field(
        None,
        alias="endTime",
        description="Epoch timestamp in milliseconds for when the operation ended.",
        example=1,
        ge=0,
    )


class RigOperationIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external ID of the wellbore where the operation took place. The asset must have been ingested as a wellbore with the same source name as this Rig Operation.",
        max_length=255,
    )
    source: SourceExternalId = Field(..., description="The source external ID in CDF.")
    rig_name: str = Field(..., alias="rigName", description="The name of the rig.", max_length=255)
    start_time: Optional[int] = Field(
        None,
        alias="startTime",
        description="Epoch timestamp in milliseconds for when the operation started.",
        example=1,
        ge=0,
    )
    end_time: Optional[int] = Field(
        None,
        alias="endTime",
        description="Epoch timestamp in milliseconds for when the operation ended.",
        example=1,
        ge=0,
    )


class RigOperationIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[RigOperationIngestion] = Field(..., max_items=1000, min_items=1)


class RigOperationItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[RigOperation]
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class RigOperationFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    rig_names: Optional[List[str]] = Field(
        None, alias="rigNames", description="Filter rig operations by rig names.", example=["Rig A", "15 aerA"]
    )
    start_time: Optional[TimeRange] = Field(
        None, alias="startTime", description="Filter rig operations with start time within a given time range."
    )
    end_time: Optional[TimeRange] = Field(
        None, alias="endTime", description="Filter rig operations with end time within a given time range."
    )
    wellbore_ids: Optional[List[Identifier]] = Field(
        None,
        alias="wellboreIds",
        description="Filter rig operations that belong to one of the given wellbores.",
        max_items=1000,
        min_items=1,
    )


class RigOperationFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[RigOperationFilter] = None


class Distance(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    value: float = Field(..., description="Amount of a given unit.")
    unit: DistanceUnitEnum


class Duration(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    value: float
    unit: DurationUnitEnum


class DoglegSeverityUnit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    angle_unit: AngleUnitEnum = Field(..., alias="angleUnit")
    distance_unit: DistanceUnitEnum = Field(..., alias="distanceUnit")
    distance_interval: Optional[float] = Field(None, alias="distanceInterval", example=30.0)


class SequenceExternalIdItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[SequenceExternalId] = Field(..., max_items=1000, min_items=1)
    ignore_unknown_ids: Optional[bool] = Field(
        False, alias="ignoreUnknownIds", description="Ignore sequence external ID's that are not found."
    )


class GeneralExternalId(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    external_id: str = Field(..., alias="externalId", description="An identifier for a CDF resource.")
    type: ExternalIdTypeEnum


class GeneralExternalIdItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[GeneralExternalId]


class WellPropertiesSummaryItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellPropertiesSummaryRow]


class WellSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: Optional[str] = Field(
        None,
        alias="matchingId",
        description="Unique identifier used to match wells from different sources. The matchingId must be unique within a source.",
    )
    name: str = Field(..., description="Name of the well.", example="15/9-19 SR")
    description: Optional[str] = Field(None, description="Description of the well.")
    unique_well_identifier: Optional[str] = Field(
        None,
        alias="uniqueWellIdentifier",
        description="`uniqueWellIdentifier` (also called UWI) is a guaranteed unique\nidentifier. All wells that share the same `matchingId` must also\nshare the same `uniqueWellIdentifier`, or have it set to `null`.\n",
        max_length=255,
    )
    country: Optional[str] = Field(None, description="The country the well is located in.", example="Norway")
    quadrant: Optional[str] = Field(
        None,
        description="The quadrant of the well. This is the first part of the unique well identifier used on the norwegian continental shelf. The well `15/9-19-RS` in the VOLVE field is in quadrant `15`.",
        example="15",
    )
    region: Optional[str] = Field(None, description="Region of the well.", example="North Sea")
    spud_date: Optional[date] = Field(
        None,
        alias="spudDate",
        description="The date a new well was _spudded_, or the date of first actual penetration of the earth with a drilling bit.",
        example="1993-02-17",
    )
    block: Optional[str] = Field(
        None,
        description="The block of the well. This is the second part of the unique well identifer used on the norwegian continental shelf. The well `15/9-19-RS` in the VOLVE field is in block `15/9`.",
        example="15/9",
    )
    field: Optional[str] = Field(None, description="Field of the well.", example="VOLVE")
    operator: Optional[str] = Field(None, description="Operator of the well.", example="ABP Norway AS")
    well_type: Optional[str] = Field(
        None,
        alias="wellType",
        description="The type of the well: For example exploration or development.",
        example="exploration",
    )
    license: Optional[str] = Field(
        None, description="The name of the license this well is associated with.", example="1092"
    )
    water_depth: Optional[Distance] = Field(
        None,
        alias="waterDepth",
        description="Water depth of the well. Vertical distance from the mean sea level to the sea bed.",
    )
    wellhead: Optional[Wellhead] = None
    source: AssetSource = Field(..., description="Connection between the well and the well asset with a given source.")


class DeleteWells(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[AssetSource] = Field(..., max_items=1000, min_items=1)
    recursive: Optional[bool] = Field(
        False,
        description="If set to true, it will delete associated wellbores, measurements, NPT/NDS etc.\nIf set to false, it will fail if one of the wells have associated wellbores.",
    )


class WellWellheadView(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    well_matching_id: str = Field(..., alias="wellMatchingId")
    wellhead: Wellhead


class FieldSources(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[AssetSource] = None
    description: Optional[AssetSource] = None
    country: Optional[AssetSource] = None
    quadrant: Optional[AssetSource] = None
    spud_date: Optional[AssetSource] = Field(None, alias="spudDate")
    block: Optional[AssetSource] = None
    field: Optional[AssetSource] = None
    operator: Optional[AssetSource] = None
    well_type: Optional[AssetSource] = Field(None, alias="wellType")
    license: Optional[AssetSource] = None
    water_depth: Optional[AssetSource] = Field(None, alias="waterDepth")
    wellhead: Optional[AssetSource] = None


class IncompleteWell(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(..., alias="matchingId")
    sources: List[AssetSource]
    missing: List[str]


class IncompleteWellItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[IncompleteWell]
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class FieldSources1(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: Optional[AssetSource] = None
    description: Optional[AssetSource] = None
    datum: Optional[AssetSource] = None


class IncompleteWellbore(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(..., alias="matchingId")
    sources: List[AssetSource]
    missing: List[str]


class IncompleteWellboreItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[IncompleteWellbore] = Field(..., example=[])
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class WaterDepthLimits(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min: Optional[Distance] = None
    max: Optional[Distance] = None


class Npt(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external ID of the wellbore the event is associated to. The asset must have been ingested as a wellbore with the same source as this NPT event.",
    )
    wellbore_matching_id: str = Field(
        ..., alias="wellboreMatchingId", description="The matching id of the wellbore related to NPT event."
    )
    npt_code: Optional[str] = Field(
        None, alias="nptCode", description="The NPT code to identify event.", example="DPRB"
    )
    npt_code_detail: Optional[str] = Field(
        None, alias="nptCodeDetail", description="The more detailed NPT code that identifies the event.", example="DERK"
    )
    npt_level: Optional[str] = Field(
        None,
        alias="nptLevel",
        description='The level of non-productive time for the activity. The NPT level must be one of: "0", "1", "2", "3", "4", or "5".',
        example="0",
    )
    source: EventSource
    description: Optional[str] = Field(None, description="Description of the NPT event.")
    start_time: Optional[int] = Field(
        None,
        alias="startTime",
        description="The time the depth measurement started. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
    )
    end_time: Optional[int] = Field(
        None,
        alias="endTime",
        description="The time the depth measurement completed. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
    )
    measured_depth: Optional[Distance] = Field(
        None, alias="measuredDepth", description="Measured depth for the NPT event."
    )
    duration: Optional[float] = Field(None, description="Duration (hours) of the NPT event..", example=6.5)
    root_cause: Optional[str] = Field(
        None, alias="rootCause", description="Root cause for the NPT event.", example="Leakage in pipe"
    )
    location: Optional[str] = Field(None, description="Location of NPT event.")
    subtype: Optional[str] = Field(None, description="Subtype of NPT event.")


class NptIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external ID of the wellbore the event is associated to. The asset must have been ingested as a wellbore with the same source as this NPT event.",
    )
    npt_code: Optional[str] = Field(
        None, alias="nptCode", description="The NPT code to identify event.", example="DPRB"
    )
    npt_code_detail: Optional[str] = Field(
        None, alias="nptCodeDetail", description="The more detailed NPT code that identifies the event.", example="DERK"
    )
    npt_level: Optional[str] = Field(
        None,
        alias="nptLevel",
        description='The level of non-productive time for the activity. The NPT level must be one of: "0", "1", "2", "3", "4", or "5".',
        example="0",
    )
    source: EventSource
    description: Optional[str] = Field(None, description="Description of the NPT event.")
    start_time: Optional[int] = Field(
        None,
        alias="startTime",
        description="The time the depth measurement started. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
    )
    end_time: Optional[int] = Field(
        None,
        alias="endTime",
        description="The time the depth measurement completed. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
    )
    measured_depth: Optional[Distance] = Field(
        None, alias="measuredDepth", description="Measured depth for the NPT event."
    )
    root_cause: Optional[str] = Field(
        None, alias="rootCause", description="Root cause for the NPT event.", example="Leakage in pipe"
    )
    location: Optional[str] = Field(None, description="Location of NPT event.")
    subtype: Optional[str] = Field(None, description="Subtype of NPT event.")


class NptIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[NptIngestion] = Field(..., max_items=1000, min_items=1)


class NptItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Npt]
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class NptFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measured_depth: Optional[DistanceRange] = Field(None, alias="measuredDepth")
    duration: Optional[DurationRange] = None
    npt_code: Optional[PropertyFilter] = Field(None, alias="nptCode")
    npt_code_detail: Optional[PropertyFilter] = Field(None, alias="nptCodeDetail")
    root_cause: Optional[PropertyFilter] = Field(None, alias="rootCause")
    location: Optional[PropertyFilter] = None
    subtype: Optional[PropertyFilter] = None
    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds", max_items=1000, min_items=1)


class NptFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[NptFilter] = None


class WellNptFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    exists: Optional[bool] = Field(True, description="Set to false to filter on non-existence of particular npt events")
    measured_depth: Optional[DistanceRange] = Field(None, alias="measuredDepth")
    duration: Optional[DurationRange] = None
    npt_codes: Optional[ContainsAllOrAny] = Field(None, alias="nptCodes")
    npt_code_details: Optional[ContainsAllOrAny] = Field(None, alias="nptCodeDetails")


class NptAggregateRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: NptAggregateRequestFilter
    group_by: List[NptAggregateEnum] = Field(..., alias="groupBy")


class NptAggregateRow(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    count: int = Field(..., description="Number of NPT events that matches this group")
    duration: Optional[Duration] = None
    npt_code: Optional[str] = Field(None, alias="nptCode")
    npt_code_detail: Optional[str] = Field(None, alias="nptCodeDetail")


class Nds(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external ID of the wellbore the event is associated to. The asset must have been ingested as a wellbore with the same source as this NDS event.",
    )
    wellbore_matching_id: str = Field(
        ..., alias="wellboreMatchingId", description="The matching id of the wellbore related to NDS event."
    )
    source: EventSource
    description: Optional[str] = Field(
        None, description="Textual description of the event.", example="REAM OUT TIGHT HOLE"
    )
    hole_diameter: Optional[Distance] = Field(None, alias="holeDiameter")
    top_measured_depth: Optional[Distance] = Field(
        None, alias="topMeasuredDepth", description="The top measured depth that this event is associated with."
    )
    base_measured_depth: Optional[Distance] = Field(
        None, alias="baseMeasuredDepth", description="The base measured depth that this event is associated with."
    )
    risk_type: Optional[str] = Field(None, alias="riskType", description="Type of NDS risk.", example="some risk type")
    subtype: Optional[str] = Field(None, description="Subtype of NDS risk.", example="some subtype")
    severity: Optional[int] = Field(
        None, description="Severity of the NDS event. The value should be between 0-5 where 5 is the highest."
    )
    probability: Optional[int] = Field(
        None, description="Probability of the NDS. The value should be between 0-5 where 5 is the highest."
    )


class NdsItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Nds]
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class NdsIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external ID of the wellbore the event is associated to. The asset must have been ingested as a wellbore with the same source as this NDS event.",
    )
    source: EventSource
    description: Optional[str] = Field(
        None, description="Textual description of the event.", example="REAM OUT TIGHT HOLE"
    )
    hole_diameter: Optional[Distance] = Field(None, alias="holeDiameter")
    top_measured_depth: Optional[Distance] = Field(
        None, alias="topMeasuredDepth", description="The top measured depth that this event is associated with."
    )
    base_measured_depth: Optional[Distance] = Field(
        None, alias="baseMeasuredDepth", description="The base measured depth that this event is associated with."
    )
    severity: Optional[int] = Field(
        None, description="Severity of the NDS event. The value should be between 0-5 where 5 is the highest."
    )
    risk_type: Optional[str] = Field(None, alias="riskType", description="Type of NDS risk.", example="some risk type")
    subtype: Optional[str] = Field(None, description="Subtype of NDS risk.", example="some subtype")
    probability: Optional[int] = Field(
        None, description="Probability of the NDS. The value should be between 0-5 where 5 is the highest."
    )


class NdsIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[NdsIngestion] = Field(..., max_items=1000, min_items=1)
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class NdsFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    top_measured_depth: Optional[DistanceRange] = Field(None, alias="topMeasuredDepth")
    base_measured_depth: Optional[DistanceRange] = Field(None, alias="baseMeasuredDepth")
    probabilities: Optional[List[int]] = None
    severities: Optional[List[int]] = None
    risk_type: Optional[PropertyFilter] = Field(None, alias="riskType")
    subtype: Optional[PropertyFilter] = None
    wellbore_ids: Optional[List[Identifier]] = Field(None, alias="wellboreIds", max_items=1000, min_items=1)


class NdsFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[NdsFilter] = None


class WellNdsFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    exists: Optional[bool] = Field(True, description="Set to false to filter on non-existence of particular nds events")
    severities: Optional[ContainsAllOrAnyInt] = None
    probabilities: Optional[ContainsAllOrAnyInt] = None
    risk_types: Optional[ContainsAllOrAny] = Field(None, alias="riskTypes")


class NdsAggregateRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: NdsAggregateRequestFilter
    group_by: List[NdsAggregateEnum] = Field(..., alias="groupBy")


class NdsAggregate(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_matching_id: str = Field(..., alias="wellboreMatchingId")
    items: List[NdsAggregateRow] = Field(..., min_items=1)


class DepthIndexColumn(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    column_external_id: str = Field(
        ..., alias="columnExternalId", description="External ID of the sequence column", example="MD"
    )
    unit: DistanceUnit
    type: DepthIndexTypeEnum


class MeasurementTypeItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[MeasurementType]


class TimeMeasurement(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str
    source_name: str = Field(..., alias="sourceName")
    external_id: str = Field(..., alias="externalId")
    description: Optional[str] = None
    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    columns: List[TimeMeasurementColumn]


class TimeMeasurementIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TimeMeasurement] = Field(..., max_items=1000, min_items=1)


class TimeMeasurementItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TimeMeasurement] = Field(..., max_items=1000)
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class TimeMeasurementFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[TimeMeasurementFilter] = None


class TrajectoryIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external ID of the wellbore this trajectory is associated with. The asset must have been ingested as a wellbore with the same source as this trajectory.",
    )
    source: SequenceSource
    type: Optional[str] = None
    measured_depth_unit: DistanceUnitEnum = Field(..., alias="measuredDepthUnit")
    inclination_unit: AngleUnitEnum = Field(..., alias="inclinationUnit")
    azimuth_unit: AngleUnitEnum = Field(..., alias="azimuthUnit")
    dogleg_severity_unit: Optional[DoglegSeverityUnit] = Field(None, alias="doglegSeverityUnit")
    phase: Optional[PhaseEnum] = None
    rows: List[TrajectoryIngestionRow]


class WellTopSurfaceIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., description="The name of the lithostratigraphic unit")
    top_measured_depth: float = Field(
        ..., alias="topMeasuredDepth", description="The measured depth of the top of the lithostratigraphic unit"
    )
    base_measured_depth: Optional[float] = Field(
        None, alias="baseMeasuredDepth", description="The measured depth of the base of the lithostratigraphic unit."
    )
    lithostratigraphic: Optional[Lithostratigraphic] = None
    chronostratigraphic: Optional[Chronostratigraphic] = None


class WellTopSurface(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    name: str = Field(..., description="The name of the lithostratigraphic unit")
    top: WellTopSurfaceDepth = Field(..., description="The top surface of the lithostratigraphic unit")
    base: Optional[WellTopSurfaceDepth] = Field(
        None, description="The base of the lithostratigraphic unit, if available"
    )
    lithostratigraphic: Optional[Lithostratigraphic] = None
    chronostratigraphic: Optional[Chronostratigraphic] = None


class WellTopsFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[WellTopsFilter] = None


class DoglegSeverity(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    unit: DoglegSeverityUnit
    value: float


class DoglegSeverityRange(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    unit: DoglegSeverityUnit
    min: Optional[float] = None
    max: Optional[float] = None


class TrajectoryData(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    wellbore_matching_id: str = Field(
        ..., alias="wellboreMatchingId", description="The matching id of the wellbore related to trajectory data."
    )
    source: SequenceSource
    type: Optional[str] = None
    measured_depth_unit: DistanceUnitEnum = Field(..., alias="measuredDepthUnit")
    inclination_unit: AngleUnitEnum = Field(..., alias="inclinationUnit")
    azimuth_unit: AngleUnitEnum = Field(..., alias="azimuthUnit")
    true_vertical_depth_unit: DistanceUnitEnum = Field(..., alias="trueVerticalDepthUnit")
    equivalent_departure_unit: DistanceUnitEnum = Field(..., alias="equivalentDepartureUnit")
    offset_unit: DistanceUnitEnum = Field(..., alias="offsetUnit")
    dogleg_severity_unit: DoglegSeverityUnit = Field(..., alias="doglegSeverityUnit")
    dogleg_severity_is_computed: bool = Field(
        ...,
        alias="doglegSeverityIsComputed",
        description="Indicates whether the dogleg severities in this trajectory were computed by the well service (true), or whether it was provided during ingestion (false)",
    )
    rows: List[TrajectoryDataRow]


class TrajectoryInterpolationRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_id: Identifier = Field(
        ..., alias="wellboreId", description="Interpolate the definitive trajectory of this wellbore"
    )
    measured_depths: List[float] = Field(..., alias="measuredDepths")
    measured_depth_unit: DistanceUnit = Field(..., alias="measuredDepthUnit")
    true_vertical_depth_unit: Optional[DistanceUnit] = Field(None, alias="trueVerticalDepthUnit")


class TrueVerticalDepths(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    true_vertical_depths: List[float] = Field(..., alias="trueVerticalDepths")
    measured_depths: List[float] = Field(..., alias="measuredDepths")
    true_vertical_depth_unit: DistanceUnit = Field(..., alias="trueVerticalDepthUnit")
    sequence_source: SequenceSource = Field(..., alias="sequenceSource")
    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    wellbore_matching_id: str = Field(..., alias="wellboreMatchingId")


class CasingCementing(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    top_measured_depth: Optional[Distance] = Field(
        None,
        alias="topMeasuredDepth",
        description="Top measured depth of the cementing. If both `baseMeasuredDepth` and `topMeasuredDepth` are set, then `baseMeasuredDepth` must be larger or equal to `topMeasuredDepth`.\n",
    )
    base_measured_depth: Optional[Distance] = Field(
        None,
        alias="baseMeasuredDepth",
        description="Base measured depth of the cementing. If both `baseMeasuredDepth` and `topMeasuredDepth` are set, then `baseMeasuredDepth` must be larger or equal to `topMeasuredDepth`.\n",
    )


class LinearWeightUnit(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    weight_unit: WeightUnitEnum = Field(..., alias="weightUnit")
    depth_unit: DistanceUnitEnum = Field(..., alias="depthUnit")


class HoleSectionIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    source: GeneralExternalId
    name: str = Field(..., description="Name for the Hole Section.")
    hole_size: float = Field(
        ..., alias="holeSize", description="Hole size of the hole section in hole section group hole size unit."
    )
    bit_size: float = Field(
        ..., alias="bitSize", description="Bit size of the hole section in hole section group bit size unit."
    )
    start_time: Optional[int] = Field(
        None,
        alias="startTime",
        description="The timestamp in milliseconds since the epoch (Jan 1, 1970) for when the hole sections was started.",
        example=1,
    )
    end_time: Optional[int] = Field(
        None,
        alias="endTime",
        description="The timestamp in milliseconds since the epoch (Jan 1, 1970) for when the hole sections was completed.",
        example=1,
    )
    top_measured_depth: float = Field(
        ..., alias="topMeasuredDepth", description="Top of the hole section - shallowest point by measured depth."
    )
    base_measured_depth: float = Field(
        ..., alias="baseMeasuredDepth", description="Base of the hole section - deepest point by measured depth."
    )


class HoleSection(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    source: GeneralExternalId
    name: str = Field(..., description="Name for the Hole Section.")
    hole_size: Optional[float] = Field(
        None, alias="holeSize", description="Hole size of the hole section in hole section group hole size unit."
    )
    bit_size: Optional[float] = Field(
        None, alias="bitSize", description="Bit size of the hole section in hole section group bit size unit."
    )
    start_time: Optional[int] = Field(
        None,
        alias="startTime",
        description="The timestamp in milliseconds since the epoch (Jan 1, 1970) for when the hole sections was started.",
        example=1,
    )
    end_time: Optional[int] = Field(
        None,
        alias="endTime",
        description="The timestamp in milliseconds since the epoch (Jan 1, 1970) for when the hole sections was completed.",
        example=1,
    )
    top_measured_depth: Optional[float] = Field(
        None, alias="topMeasuredDepth", description="Top of the hole section - shallowest point by measured depth."
    )
    base_measured_depth: Optional[float] = Field(
        None, alias="baseMeasuredDepth", description="Base of the hole section - deepest point by measured depth."
    )


class HoleSectionFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_ids: Optional[List[Identifier]] = Field(
        None,
        alias="wellboreIds",
        description="Filter hole sections that are related to one of given wellbores.",
        max_items=1000,
        min_items=1,
    )
    bit_size: Optional[Distance] = Field(
        None, alias="bitSize", description="Filter hole sections with a specific hole size.", title="Distance"
    )
    hole_size: Optional[Distance] = Field(
        None, alias="holeSize", description="Filter hole sections with a specific bit size.", title="Distance"
    )
    top_measured_depth: Optional[DistanceRange] = Field(
        None,
        alias="topMeasuredDepth",
        description="Filter hole sections with hole top in a given measured depth range.",
        title="DistanceRange",
    )
    base_measured_depth: Optional[DistanceRange] = Field(
        None,
        alias="baseMeasuredDepth",
        description="Filter hole sections with hole base in a given measured depth range.",
        title="DistanceRange",
    )
    start_time: Optional[TimeRange] = Field(
        None,
        alias="startTime",
        description="Filter hole sections with construction start time within a given time range.",
        title="DistanceRange",
    )
    end_time: Optional[TimeRange] = Field(
        None,
        alias="endTime",
        description="Filter hole sections with construction end time within a given time range.",
        title="DistanceRange",
    )
    is_definitive: Optional[bool] = Field(
        None,
        alias="isDefinitive",
        description="Specifies if the query is to return only definitive or not. If value is not set, then all hole sections are returned.",
    )


class HoleSectionFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[HoleSectionFilter] = None


class WellTrajectoryFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    max_measured_depth: Optional[DistanceRange] = Field(None, alias="maxMeasuredDepth")
    max_true_vertical_depth: Optional[DistanceRange] = Field(None, alias="maxTrueVerticalDepth")
    max_inclination: Optional[AngleRange] = Field(None, alias="maxInclination")
    max_dogleg_severity: Optional[DoglegSeverityRange] = Field(None, alias="maxDoglegSeverity")


class PolygonFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    geometry: str = Field(..., example="POINT (1.42 1.35)")
    crs: str = Field(..., example="EPSG:4326")
    geometry_type: Optional[GeometryTypeEnum] = Field("WKT", alias="geometryType")


class WellDepthMeasurementFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_types: Optional[ContainsAllOrAnyMeasurementType] = Field(None, alias="measurementTypes")
    measured_depth: Optional[DistanceRange] = Field(None, alias="measuredDepth")
    true_vertical_depth: Optional[DistanceRange] = Field(None, alias="trueVerticalDepth")


class WellTimeMeasurementFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_types: Optional[ContainsAllOrAnyMeasurementType] = Field(None, alias="measurementTypes")


class WellHoleSectionFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    hole_size: Optional[Distance] = Field(None, alias="holeSize")
    bit_size: Optional[Distance] = Field(None, alias="bitSize")
    exists: Optional[bool] = Field(
        True, description="Set to false to filter on wellbores that do not have registered hole sections\n"
    )


class DepthMeasurementDataRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    sequence_external_id: str = Field(..., alias="sequenceExternalId")
    measured_depth: Optional[DistanceRange] = Field(None, alias="measuredDepth")
    depth_unit: Optional[DistanceUnit] = Field(None, alias="depthUnit")
    measurement_types: Optional[List[str]] = Field(None, alias="measurementTypes")
    column_external_ids: Optional[List[str]] = Field(None, alias="columnExternalIds")
    top_surface_name: Optional[str] = Field(None, alias="topSurfaceName")
    limit: Optional[int] = Field(
        None,
        description="Maximum number of rows returned in one request. If there is more data beyond this limit, a cursor will be returned to enable further fetching of data.",
        ge=1,
        le=10000,
    )
    cursor: Optional[str] = Field(
        None,
        description="Cursor for pagination returned from a previous request. Apart from cursor and limit, the rest of the request object must be the same as for the original request.",
    )


class DepthMeasurementHoleSectionFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    bit_size: Optional[Distance] = Field(None, alias="bitSize")
    hole_size: Optional[Distance] = Field(None, alias="holeSize")


class DepthMeasurementDataColumn(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    external_id: str = Field(
        ...,
        alias="externalId",
        description="User provided column identifier (Unique for a given sequence)",
        example="DPS1",
    )
    name: Optional[str] = Field(None, description="Human readable name of the column", example="Depth sensor 1")
    measurement_type: str = Field(..., alias="measurementType")
    unit: str = Field(..., description="Unit for the measurement type", example="meter")
    value_type: DepthMeasurementValueTypeEnum = Field(..., alias="valueType")


class DeleteExternalIdSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[ExternalIdSource] = Field(
        ..., description="List of externalIds to delete.", max_items=1000, min_items=1
    )


class DeleteSources(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Source] = Field(..., max_items=1000, min_items=1)


class SourceItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Source] = Field(..., max_items=1000)


class MnemonicMatch(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    company_name: str = Field(..., alias="companyName")
    measurement_type: str = Field(..., alias="measurementType", example="measured depth")
    primary_quantity_class: Optional[str] = Field(None, alias="primaryQuantityClass")
    tools: List[MnemonicMatchTool]


class MeasurementTypeFilterRequest(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[MeasurementTypeFilter] = None


class MeasurementTypeDetailsItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[MeasurementTypeDetails]


class Datum(Distance):
    class Config:
        allow_population_by_field_name = True

    reference: str = Field(
        ..., description='The name of the reference point. Eg. "KB" for kelly bushing.', example="KB"
    )


class WellSourceItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellSource] = Field(..., max_items=1000, min_items=1)
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class WellWellheadViewItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellWellheadView]
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class Wellbore(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(
        ...,
        alias="matchingId",
        description="Unique identifier used to match wellbores from different sources. The matchingId must be unique within a source.",
    )
    name: str = Field(..., description="Name of the wellbore.")
    description: Optional[str] = Field(None, description="Description of the wellbore.")
    well_matching_id: str = Field(..., alias="wellMatchingId", description="Matching id of the associated well.")
    parent_wellbore_matching_id: Optional[str] = Field(
        None, alias="parentWellboreMatchingId", description="Parent wellbore if it exists."
    )
    unique_wellbore_identifier: Optional[str] = Field(
        None,
        alias="uniqueWellboreIdentifier",
        description="`uniqueWellboreIdentifier` (also called UBI) is a guaranteed unique\nidentifier. All wellbores that share the same `matchingId` must also\nshare the same `uniqueWellboreIdentifier`, or have it set to `null`.\n",
        max_length=255,
    )
    sources: List[AssetSource] = Field(..., description="List of sources that are associated to this wellbore.")
    datum: Optional[Datum] = None
    total_drilling_days: Optional[float] = Field(
        None, alias="totalDrillingDays", description="Total days of drilling for this wellbore", example=36.5
    )
    kickoff_measured_depth: Optional[Distance] = Field(
        None,
        alias="kickoffMeasuredDepth",
        description="The depth where the sidetrack started. This only makes sense if this wellbore is a sidetrack and has a parent wellbore.",
    )


class WellboreSource(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: Optional[str] = Field(
        None,
        alias="matchingId",
        description="Unique identifier used to match wellbores from different sources. The matchingId must be unique within a source.",
    )
    name: str = Field(..., description="Name of the wellbore.")
    description: Optional[str] = Field(None, description="Description of the wellbore.")
    well_asset_external_id: str = Field(
        ...,
        alias="wellAssetExternalId",
        description="The asset external ID of the well this wellbore is associated with.",
    )
    parent_wellbore_asset_external_id: Optional[str] = Field(
        None, alias="parentWellboreAssetExternalId", description="Parent wellbore if it exists."
    )
    unique_wellbore_identifier: Optional[str] = Field(
        None,
        alias="uniqueWellboreIdentifier",
        description="`uniqueWellboreIdentifier` (also called UBI) is a guaranteed unique\nidentifier. All wellbores that share the same `matchingId` must also\nshare the same `uniqueWellboreIdentifier`, or have it set to `null`.\n",
        max_length=255,
    )
    source: AssetSource = Field(
        ..., description="Connection between this wellbore and the wellbores asset with a given source."
    )
    datum: Optional[Datum] = None
    total_drilling_days: Optional[float] = Field(
        None, alias="totalDrillingDays", description="Total days of drilling for this wellbore", example=36.5
    )
    kickoff_measured_depth: Optional[Distance] = Field(
        None,
        alias="kickoffMeasuredDepth",
        description="The depth where the sidetrack started. This only makes sense if this wellbore is a sidetrack and has a parent wellbore.",
    )


class WellboreItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Wellbore]


class WellboreMergeDetails(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore: Wellbore
    field_sources: FieldSources1 = Field(..., alias="fieldSources")


class WellboreMergeDetailItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellboreMergeDetails]


class NptAggregate(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_matching_id: str = Field(..., alias="wellboreMatchingId")
    items: List[NptAggregateRow] = Field(..., min_items=1)


class NdsAggregateItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[NdsAggregate]


class DepthMeasurement(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external ID of the wellbore. The asset must have been ingested as a wellbore with the same source as this NPT event.",
    )
    wellbore_matching_id: str = Field(
        ..., alias="wellboreMatchingId", description="The matching id of the wellbore related to depth measurement."
    )
    source: SequenceSource
    depth_column: DepthIndexColumn = Field(..., alias="depthColumn")
    datum: Optional[Datum] = None
    columns: List[DepthMeasurementColumn]
    run: Optional[str] = Field(None, description="Run number if the depth measurement represents a well log.")
    producer: Optional[str] = Field(None, description="Producer that made the data in the depth measurement.")
    start_time: Optional[int] = Field(
        None,
        alias="startTime",
        description="The time the depth measurement started. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
    )
    end_time: Optional[int] = Field(
        None,
        alias="endTime",
        description="The time the depth measurement completed. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
    )
    depth_range: Optional[DistanceRange] = Field(None, alias="depthRange")


class DepthMeasurementIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external ID of the wellbore. The asset must have been ingested as a wellbore with the same source as this NPT event.",
    )
    source: SequenceSource
    depth_column: DepthIndexColumn = Field(..., alias="depthColumn")
    datum: Optional[Datum] = None
    columns: List[DepthMeasurementColumn]
    run: Optional[str] = Field(None, description="Run number if the depth measurement represents a well log.")
    producer: Optional[str] = Field(None, description="Producer that made the data in the depth measurement.")
    start_time: Optional[int] = Field(
        None,
        alias="startTime",
        description="The time the depth measurement started. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
    )
    end_time: Optional[int] = Field(
        None,
        alias="endTime",
        description="The time the depth measurement completed. The number of milliseconds since 00:00:00 Thursday, 1 January 1970, Coordinated Universal Time (UTC), minus leap seconds.",
    )


class DepthMeasurementItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[DepthMeasurement]
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class DepthMeasurementIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[DepthMeasurementIngestion] = Field(..., max_items=1000, min_items=1)


class Trajectory(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="The CDF asset external ID of the wellbore this trajectory is associated with. The asset must have been ingested as a wellbore with the same source as this trajectory.",
    )
    wellbore_matching_id: str = Field(
        ..., alias="wellboreMatchingId", description="The matching id of the associated wellbore."
    )
    type: Optional[str] = None
    max_measured_depth: float = Field(..., alias="maxMeasuredDepth")
    max_true_vertical_depth: float = Field(..., alias="maxTrueVerticalDepth")
    max_inclination: float = Field(..., alias="maxInclination")
    max_dogleg_severity: DoglegSeverity = Field(..., alias="maxDoglegSeverity")
    source: SequenceSource
    is_definitive: bool = Field(..., alias="isDefinitive")
    phase: Optional[PhaseEnum] = None


class TrajectoryItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Trajectory]
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class TrajectoryIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrajectoryIngestion] = Field(..., max_items=1000, min_items=1)


class WellTopsIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="External ID for the wellbore asset the well tops are associated with. Source for the wellbore and for the well tops must be the same.",
    )
    source: SequenceSource
    measured_depth_unit: DistanceUnitEnum = Field(..., alias="measuredDepthUnit")
    phase: Optional[PhaseEnum] = None
    tops: List[WellTopSurfaceIngestion]


class WellTops(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="External ID for the wellbore asset the well tops are associated with. Source for the wellbore and for the well tops must be the same.",
    )
    wellbore_matching_id: str = Field(
        ...,
        alias="wellboreMatchingId",
        description="The matching id of the wellbore containing these lithostratigraphic units.",
    )
    wellbore_name: str = Field(
        ..., alias="wellboreName", description="The name of the wellbore containing these lithostratigraphic units."
    )
    source: SequenceSource
    measured_depth_unit: DistanceUnitEnum = Field(..., alias="measuredDepthUnit")
    true_vertical_depth_unit: DistanceUnitEnum = Field(..., alias="trueVerticalDepthUnit")
    phase: Optional[PhaseEnum] = None
    is_definitive: bool = Field(
        ...,
        alias="isDefinitive",
        description="If true, this is the _definitive_ well tops for the wellbore it is associated with. A wellbore can at any single time only have one definitive well tops. When well tops are used as a proxy for depth, only definitive well tops are used.",
    )
    tops: List[WellTopSurface]


class TrajectoryInterpolationRequestItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrajectoryInterpolationRequest] = Field(..., max_items=1000, min_items=1)
    ignore_missing_trajectories: Optional[bool] = Field(
        False,
        alias="ignoreMissingTrajectories",
        description="Ignore wellbores that don't have a definitive trajectory.",
    )
    ignore_unknown_measured_depths: Optional[bool] = Field(
        False,
        alias="ignoreUnknownMeasuredDepths",
        description="Ignore measured depths that are outside the trajectory range.",
    )


class TrajectoryInterpolationItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[TrueVerticalDepths]


class LinearWeight(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    value: float
    unit: LinearWeightUnit


class HoleSectionGroupIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    source_name: str = Field(..., alias="sourceName", description="Name of the source for the hole section group.")
    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="External ID for the wellbore asset this hole section group is associated with. Source for the wellbore and for the hole section group must be the same.",
    )
    measured_depth_unit: DistanceUnitEnum = Field(..., alias="measuredDepthUnit")
    size_unit: DistanceUnitEnum = Field(..., alias="sizeUnit")
    external_id: str = Field(
        ...,
        alias="externalId",
        description="A unique identifier for the hole section group. This id will be used to reference this hole section group.",
    )
    phase: Optional[PhaseEnum] = None
    sections: List[HoleSectionIngestion] = Field(..., description="A list of hole sections for this group.")


class HoleSectionGroup(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    source_name: str = Field(..., alias="sourceName", description="Name of the source for the hole section group.")
    wellbore_asset_external_id: str = Field(
        ...,
        alias="wellboreAssetExternalId",
        description="External ID for the wellbore asset this hole section group is associated with. Source for the wellbore and for the hole section group must be the same.",
    )
    wellbore_matching_id: str = Field(
        ...,
        alias="wellboreMatchingId",
        description="The matching id of the wellbore this hole section group is associated with.",
    )
    measured_depth_unit: DistanceUnitEnum = Field(..., alias="measuredDepthUnit")
    size_unit: DistanceUnitEnum = Field(..., alias="sizeUnit")
    external_id: str = Field(
        ...,
        alias="externalId",
        description="A unique identifier for the hole section group. This id will be used to reference this hole section group.",
    )
    phase: Optional[PhaseEnum] = None
    is_definitive: Optional[bool] = Field(
        None,
        alias="isDefinitive",
        description="Describes if the hole section group is definitive. A definitive hole section group is a group that contains information about the actual hole section for a given wellbore.",
    )
    sections: List[HoleSection] = Field(..., description="A list of hole sections for this group.")


class WellFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    quadrant: Optional[PropertyFilter] = None
    region: Optional[PropertyFilter] = None
    block: Optional[PropertyFilter] = None
    field: Optional[PropertyFilter] = None
    operator: Optional[PropertyFilter] = None
    well_type: Optional[PropertyFilter] = Field(None, alias="wellType")
    license: Optional[PropertyFilter] = None
    sources: Optional[List[str]] = Field(None, example=["EDM", "Sitecom"])
    water_depth: Optional[DistanceRange] = Field(None, alias="waterDepth")
    datum: Optional[DistanceRange] = None
    spud_date: Optional[DateRange] = Field(None, alias="spudDate")
    polygon: Optional[PolygonFilter] = None
    trajectories: Optional[WellTrajectoryFilter] = None
    depth_measurements: Optional[WellDepthMeasurementFilter] = Field(None, alias="depthMeasurements")
    time_measurements: Optional[WellTimeMeasurementFilter] = Field(None, alias="timeMeasurements")
    npt: Optional[WellNptFilter] = None
    nds: Optional[WellNdsFilter] = None
    well_tops: Optional[WellTopFilter] = Field(None, alias="wellTops")
    casings: Optional[WellCasingFilter] = None
    hole_sections: Optional[WellHoleSectionFilter] = Field(None, alias="holeSections")
    data_availability: Optional[WellDataAvailabilityFilter] = Field(None, alias="dataAvailability")


class WellFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[WellFilter] = None
    search: Optional[WellSearch] = None
    output_crs: Optional[str] = Field(
        None,
        alias="outputCrs",
        description="Specifies coordinate reference system (CRS) for output\ncoordinates. The `outputCrs` must be on the format `EPSG:####` or `ESRI:####`.\nIf not specified, the CRS will be the one the wells were ingested with.\n",
        example="EPSG:4326",
    )
    aggregates: Optional[List[WellFilterAggregatesEnum]] = Field(
        [],
        description="If set, the `wellsCount` and `wellboresCount` properties in the\nresponse will be set to the total number of items that matched\nthe query.\n",
    )


class DepthMeasurementFilter(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    measurement_types: Optional[List[str]] = Field(
        None,
        alias="measurementTypes",
        description="Filter depth measurements that contains columns with one of the given measurement types.",
    )
    wellbore_ids: Optional[List[Identifier]] = Field(
        None,
        alias="wellboreIds",
        description="Filter depth measurements that belong to one of the given wellbores.",
        max_items=1000,
        min_items=1,
    )
    hole_sections: Optional[DepthMeasurementHoleSectionFilter] = Field(None, alias="holeSections")
    well_tops: Optional[DepthMeasurementWellTopsFilter] = Field(None, alias="wellTops")


class DepthMeasurementData(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    id: int
    source: SequenceSource
    depth_column: DepthIndexColumn = Field(..., alias="depthColumn")
    depth_unit: DistanceUnit = Field(..., alias="depthUnit")
    columns: List[DepthMeasurementDataColumn] = Field(..., description="Column information in order given by data")
    rows: List[DepthMeasurementRow] = Field(..., description="List of row information")
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="Cursor to get the next page of results (if available)."
    )


class MnemonicMatchGroup(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    mnemonic: str = Field(..., example="DEPT")
    matches: List[MnemonicMatch]


class Well(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    matching_id: str = Field(
        ...,
        alias="matchingId",
        description="Unique identifier used to match wells from different sources. The matchingId must be unique within a source.",
    )
    name: str = Field(..., description="Name of the well.", example="15/9-19 SR")
    description: Optional[str] = Field(None, description="Description of the well.")
    unique_well_identifier: Optional[str] = Field(
        None,
        alias="uniqueWellIdentifier",
        description="`uniqueWellIdentifier` (also called UWI) is a guaranteed unique\nidentifier. All wells that share the same `matchingId` must also\nshare the same `uniqueWellIdentifier`, or have it set to `null`.\n",
        max_length=255,
    )
    country: Optional[str] = Field(None, description="The country the well is located in.", example="Norway")
    quadrant: Optional[str] = Field(
        None,
        description="The quadrant of the well. This is the first part of the unique well identifier used on the norwegian continental shelf. The well `15/9-19-RS` in the VOLVE field is in quadrant `15`.",
        example="15",
    )
    region: Optional[str] = Field(None, description="Region of the well.", example="North Sea")
    block: Optional[str] = Field(
        None,
        description="The block of the well. This is the second part of the unique well identifer used on the norwegian continental shelf. The well `15/9-19-RS` in the VOLVE field is in block `15/9`.",
        example="15/9",
    )
    field: Optional[str] = Field(None, description="Field of the well.", example="VOLVE")
    operator: Optional[str] = Field(None, description="Operator of the well.", example="ABP Norway AS")
    spud_date: Optional[date] = Field(
        None,
        alias="spudDate",
        description="The date a new well was _spudded_, or the date of first actual penetration of the earth with a drilling bit.",
        example="1993-02-17",
    )
    well_type: Optional[str] = Field(
        None,
        alias="wellType",
        description="The type of the well: For example exploration or development.",
        example="exploration",
    )
    license: Optional[str] = Field(
        None, description="The name of the license this well is associated with.", example="1092"
    )
    wellhead: Wellhead
    water_depth: Optional[Distance] = Field(
        None,
        alias="waterDepth",
        description="Water depth of the well. Vertical distance from the mean sea level to the sea bed.",
    )
    sources: List[AssetSource] = Field(..., description="List of sources that are associated to this well.")
    wellbores: Optional[List[Wellbore]] = Field(None, description="List of wellbores that are associated to this well.")


class WellItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[Well]
    wells_count: Optional[int] = Field(
        None,
        alias="wellsCount",
        description='Number of wells that matches the query. This is only set if `aggregates` in the request body contains `"count"`.',
    )
    wellbores_count: Optional[int] = Field(
        None,
        alias="wellboresCount",
        description='Number of wellbores that matches the query. This is only set if `aggregates` in the request body contains `"count"`.',
    )
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class WellMergeDetails(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    well: Well
    field_sources: FieldSources = Field(..., alias="fieldSources")


class WellMergeDetailItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellMergeDetails]


class WellboreSourceItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellboreSource] = Field(..., max_items=1000, min_items=1)
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class NptAggregateItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[NptAggregate]


class WellTopIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellTopsIngestion] = Field(..., max_items=1000, min_items=1)


class WellTopItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[WellTops]
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="Cursor to get the next page of results (if available)."
    )


class CasingComponent(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min_inside_diameter: Optional[Distance] = Field(
        None, alias="minInsideDiameter", description="Minimum inside diameter of the casing component."
    )
    max_outside_diameter: Optional[Distance] = Field(
        None, alias="maxOutsideDiameter", description="Maximum outside diameter of the casing component."
    )
    top_measured_depth: Optional[Distance] = Field(
        None,
        alias="topMeasuredDepth",
        description="Top measured depth of the casing component. If both `baseMeasuredDepth` and `topMeasuredDepth` are set, then `baseMeasuredDepth` must be larger or equal to `topMeasuredDepth`.\n",
    )
    base_measured_depth: Optional[Distance] = Field(
        None,
        alias="baseMeasuredDepth",
        description="Base measured depth of the casing component. If both `baseMeasuredDepth` and `topMeasuredDepth` are set, then `baseMeasuredDepth` must be larger or equal to `topMeasuredDepth`.\n",
    )
    grade: Optional[str] = Field(
        None,
        description="Classification of the material used in the casing component. For example L-80, or J-55.\n",
        example="L-80",
        max_length=50,
    )
    connection_name: Optional[str] = Field(
        None, alias="connectionName", description="Name of the casing connection", max_length=50
    )
    joints: Optional[int] = Field(None, description="Number of component joints", ge=1)
    description: Optional[str] = Field(None, description="Casing component description", max_length=255)
    manufacturer: Optional[str] = Field(None, description="Casing component manufacturer", max_length=255)
    type_code: Optional[str] = Field(None, alias="typeCode", description="Casing component type", max_length=50)
    linear_weight: Optional[LinearWeight] = Field(None, alias="linearWeight")


class HoleSectionGroupsIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[HoleSectionGroupIngestion] = Field(..., max_items=1000, min_items=1)


class HoleSectionGroupsItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[HoleSectionGroup] = Field(..., min_items=0)
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )


class DepthMeasurementFilterRequest(CursorAndLimit):
    class Config:
        allow_population_by_field_name = True

    filter: Optional[DepthMeasurementFilter] = None


class MnemonicMatchItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[MnemonicMatchGroup]


class CasingAssembly(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    min_inside_diameter: Distance = Field(
        ..., alias="minInsideDiameter", description="Minimum inside diameter of the casing assembly."
    )
    min_outside_diameter: Distance = Field(
        ..., alias="minOutsideDiameter", description="Minimum outside diameter of the casing assembly."
    )
    max_outside_diameter: Distance = Field(
        ..., alias="maxOutsideDiameter", description="Maximum outside diameter of the casing assembly."
    )
    top_measured_depth: Distance = Field(
        ..., alias="topMeasuredDepth", description="Top measured depth of the casing assembly."
    )
    base_measured_depth: Distance = Field(
        ..., alias="baseMeasuredDepth", description="Base measured depth of the casing assembly."
    )
    type: Optional[str] = Field(
        None,
        description="Type of casing assembly. Examples: Intermediate casing, production casing, production liner, etc.",
        max_length=255,
    )
    report_description: Optional[str] = Field(
        None, alias="reportDescription", description="Report description of the casing assembly"
    )
    section_type_code: Optional[str] = Field(None, alias="sectionTypeCode", max_length=50)
    cementing: Optional[CasingCementing] = None
    components: Optional[List[CasingComponent]] = None


class CasingSchematicIngestion(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    casing_assemblies: List[CasingAssembly] = Field(..., alias="casingAssemblies")
    source: SequenceSource
    phase: Optional[PhaseEnum] = None


class CasingSchematic(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    wellbore_asset_external_id: str = Field(..., alias="wellboreAssetExternalId")
    wellbore_matching_id: str = Field(
        ..., alias="wellboreMatchingId", description="The matching id of the wellbore related to CasingSchematic."
    )
    casing_assemblies: List[CasingAssembly] = Field(..., alias="casingAssemblies")
    source: SequenceSource
    phase: Optional[PhaseEnum] = None
    is_definitive: Optional[bool] = Field(
        None,
        alias="isDefinitive",
        description="Describes if the casing schematic is definitive. A definitive casing schematic is a schematic that contains information about the actual casing assemblies for a given wellbore.",
    )


class CasingIngestionItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[CasingSchematicIngestion] = Field(..., max_items=1000, min_items=1)


class CasingItems(WellsBaseModel):
    class Config:
        allow_population_by_field_name = True

    items: List[CasingSchematic]
    next_cursor: Optional[str] = Field(
        None, alias="nextCursor", description="The cursor to get the next page of results (if available)."
    )
