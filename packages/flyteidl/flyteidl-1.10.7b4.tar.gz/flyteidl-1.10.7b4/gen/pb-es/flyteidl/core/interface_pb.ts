// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file flyteidl/core/interface.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { LiteralType } from "./types_pb.js";
import { ArtifactID, ArtifactQuery, ArtifactTag } from "./artifact_id_pb.js";
import { Literal } from "./literals_pb.js";

/**
 * Defines a strongly typed variable.
 *
 * @generated from message flyteidl.core.Variable
 */
export class Variable extends Message<Variable> {
  /**
   * Variable literal type.
   *
   * @generated from field: flyteidl.core.LiteralType type = 1;
   */
  type?: LiteralType;

  /**
   * +optional string describing input variable
   *
   * @generated from field: string description = 2;
   */
  description = "";

  /**
   * +optional This object allows the user to specify how Artifacts are created.
   * name, tag, partitions can be specified. The other fields (version and project/domain) are ignored.
   *
   * @generated from field: flyteidl.core.ArtifactID artifact_partial_id = 3;
   */
  artifactPartialId?: ArtifactID;

  /**
   * @generated from field: flyteidl.core.ArtifactTag artifact_tag = 4;
   */
  artifactTag?: ArtifactTag;

  constructor(data?: PartialMessage<Variable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.Variable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "message", T: LiteralType },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "artifact_partial_id", kind: "message", T: ArtifactID },
    { no: 4, name: "artifact_tag", kind: "message", T: ArtifactTag },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Variable {
    return new Variable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Variable {
    return new Variable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Variable {
    return new Variable().fromJsonString(jsonString, options);
  }

  static equals(a: Variable | PlainMessage<Variable> | undefined, b: Variable | PlainMessage<Variable> | undefined): boolean {
    return proto3.util.equals(Variable, a, b);
  }
}

/**
 * A map of Variables
 *
 * @generated from message flyteidl.core.VariableMap
 */
export class VariableMap extends Message<VariableMap> {
  /**
   * Defines a map of variable names to variables.
   *
   * @generated from field: map<string, flyteidl.core.Variable> variables = 1;
   */
  variables: { [key: string]: Variable } = {};

  constructor(data?: PartialMessage<VariableMap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.VariableMap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "variables", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Variable} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VariableMap {
    return new VariableMap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VariableMap {
    return new VariableMap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VariableMap {
    return new VariableMap().fromJsonString(jsonString, options);
  }

  static equals(a: VariableMap | PlainMessage<VariableMap> | undefined, b: VariableMap | PlainMessage<VariableMap> | undefined): boolean {
    return proto3.util.equals(VariableMap, a, b);
  }
}

/**
 * Defines strongly typed inputs and outputs.
 *
 * @generated from message flyteidl.core.TypedInterface
 */
export class TypedInterface extends Message<TypedInterface> {
  /**
   * @generated from field: flyteidl.core.VariableMap inputs = 1;
   */
  inputs?: VariableMap;

  /**
   * @generated from field: flyteidl.core.VariableMap outputs = 2;
   */
  outputs?: VariableMap;

  constructor(data?: PartialMessage<TypedInterface>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.TypedInterface";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "inputs", kind: "message", T: VariableMap },
    { no: 2, name: "outputs", kind: "message", T: VariableMap },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypedInterface {
    return new TypedInterface().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypedInterface {
    return new TypedInterface().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypedInterface {
    return new TypedInterface().fromJsonString(jsonString, options);
  }

  static equals(a: TypedInterface | PlainMessage<TypedInterface> | undefined, b: TypedInterface | PlainMessage<TypedInterface> | undefined): boolean {
    return proto3.util.equals(TypedInterface, a, b);
  }
}

/**
 * A parameter is used as input to a launch plan and has
 * the special ability to have a default value or mark itself as required.
 *
 * @generated from message flyteidl.core.Parameter
 */
export class Parameter extends Message<Parameter> {
  /**
   * +required Variable. Defines the type of the variable backing this parameter.
   *
   * @generated from field: flyteidl.core.Variable var = 1;
   */
  var?: Variable;

  /**
   * +optional
   *
   * @generated from oneof flyteidl.core.Parameter.behavior
   */
  behavior: {
    /**
     * Defines a default value that has to match the variable type defined.
     *
     * @generated from field: flyteidl.core.Literal default = 2;
     */
    value: Literal;
    case: "default";
  } | {
    /**
     * +optional, is this value required to be filled.
     *
     * @generated from field: bool required = 3;
     */
    value: boolean;
    case: "required";
  } | {
    /**
     * This is an execution time search basically that should result in exactly one Artifact with a Type that
     * matches the type of the variable.
     *
     * @generated from field: flyteidl.core.ArtifactQuery artifact_query = 4;
     */
    value: ArtifactQuery;
    case: "artifactQuery";
  } | {
    /**
     * @generated from field: flyteidl.core.ArtifactID artifact_id = 5;
     */
    value: ArtifactID;
    case: "artifactId";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Parameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.Parameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "var", kind: "message", T: Variable },
    { no: 2, name: "default", kind: "message", T: Literal, oneof: "behavior" },
    { no: 3, name: "required", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "behavior" },
    { no: 4, name: "artifact_query", kind: "message", T: ArtifactQuery, oneof: "behavior" },
    { no: 5, name: "artifact_id", kind: "message", T: ArtifactID, oneof: "behavior" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Parameter {
    return new Parameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Parameter {
    return new Parameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Parameter {
    return new Parameter().fromJsonString(jsonString, options);
  }

  static equals(a: Parameter | PlainMessage<Parameter> | undefined, b: Parameter | PlainMessage<Parameter> | undefined): boolean {
    return proto3.util.equals(Parameter, a, b);
  }
}

/**
 * A map of Parameters.
 *
 * @generated from message flyteidl.core.ParameterMap
 */
export class ParameterMap extends Message<ParameterMap> {
  /**
   * Defines a map of parameter names to parameters.
   *
   * @generated from field: map<string, flyteidl.core.Parameter> parameters = 1;
   */
  parameters: { [key: string]: Parameter } = {};

  constructor(data?: PartialMessage<ParameterMap>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.ParameterMap";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parameters", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Parameter} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ParameterMap {
    return new ParameterMap().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ParameterMap {
    return new ParameterMap().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ParameterMap {
    return new ParameterMap().fromJsonString(jsonString, options);
  }

  static equals(a: ParameterMap | PlainMessage<ParameterMap> | undefined, b: ParameterMap | PlainMessage<ParameterMap> | undefined): boolean {
    return proto3.util.equals(ParameterMap, a, b);
  }
}

