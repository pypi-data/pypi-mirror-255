"""Generated by Sideko (sideko.dev)"""
from enum import Enum
from typing import Union, Type, TypeVar, Literal

from httpx import Response
from pydantic import BaseModel

from sideko_netlify_api.schemas import BinaryResponse
from sideko_netlify_api.errors import InvalidResponseBodyException

T = TypeVar("T")


class StatusCodeRange(Enum):
    INFO = 1
    SUCCESS = 2
    REDIRECTION = 3
    CLIENT_ERROR = 4
    SERVER_ERROR = 5


class ResponseCaster:
    def __init__(
        self,
        *,
        status_code: Union[int, StatusCodeRange, Literal["default"]],
        expected_type: Type[T],
        is_error: bool,
    ):
        self.status_code = status_code
        self.expected_type = expected_type
        self.is_error = is_error

    @property
    def status_code_str(self) -> str:
        if isinstance(self.status_code, StatusCodeRange):
            return f"{self.status_code.value}XX"

        return str(self.status_code)

    def match_code(self, code: int) -> bool:
        if isinstance(self.status_code, StatusCodeRange):
            return int(code / 100) == self.status_code.value
        elif isinstance(self.status_code, int):
            return self.status_code == code
        else:
            # default always matches
            return True

    def cast_response(self, response: Response) -> T:
        """
        Pydantic has some excellent casting functionality for json bodies.
        Dynamically create a pydantic class with the expected type to
        attempt casting network json data for non-binary responses
        """
        if not response.content:
            return None
        try:
            if self.expected_type == BinaryResponse:
                return BinaryResponse(
                    content=response.content, headers=response.headers
                )

            class Caster(BaseModel):
                data: self.expected_type

            return Caster(data=response.json()).data
        except:
            raise InvalidResponseBodyException(
                response=response, expected_type=self.expected_type
            )
