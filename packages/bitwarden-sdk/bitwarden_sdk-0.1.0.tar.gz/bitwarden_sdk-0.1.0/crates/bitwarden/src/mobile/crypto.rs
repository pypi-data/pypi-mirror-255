use std::collections::HashMap;

use bitwarden_crypto::{AsymmetricEncString, EncString};
#[cfg(feature = "internal")]
use bitwarden_crypto::{KeyDecryptable, KeyEncryptable, MasterKey, SymmetricCryptoKey};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[cfg(feature = "internal")]
use crate::client::{LoginMethod, UserLoginMethod};
use crate::{
    client::Kdf,
    error::{Error, Result},
    Client,
};

#[cfg(feature = "internal")]
#[derive(Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "mobile", derive(uniffi::Record))]
pub struct InitUserCryptoRequest {
    /// The user's KDF parameters, as received from the prelogin request
    pub kdf_params: Kdf,
    /// The user's email address
    pub email: String,
    /// The user's encrypted private key
    pub private_key: String,
    /// The initialization method to use
    pub method: InitUserCryptoMethod,
}

#[cfg(feature = "internal")]
#[derive(Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "mobile", derive(uniffi::Enum))]
pub enum InitUserCryptoMethod {
    Password {
        /// The user's master password
        password: String,
        /// The user's encrypted symmetric crypto key
        user_key: String,
    },
    DecryptedKey {
        /// The user's decrypted encryption key, obtained using `get_user_encryption_key`
        decrypted_user_key: String,
    },
    Pin {
        /// The user's PIN
        pin: String,
        /// The user's symmetric crypto key, encrypted with the PIN. Use `derive_pin_key` to obtain
        /// this.
        pin_protected_user_key: EncString,
    },
    AuthRequest {
        /// Private Key generated by the `crate::auth::new_auth_request`.
        request_private_key: String,

        method: AuthRequestMethod,
    },
}

#[cfg(feature = "internal")]
#[derive(Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "mobile", derive(uniffi::Enum))]
pub enum AuthRequestMethod {
    UserKey {
        /// User Key protected by the private key provided in `AuthRequestResponse`.
        protected_user_key: AsymmetricEncString,
    },
    MasterKey {
        /// Master Key protected by the private key provided in `AuthRequestResponse`.
        protected_master_key: AsymmetricEncString,
        /// User Key protected by the MasterKey, provided by the auth response.
        auth_request_key: EncString,
    },
}

#[cfg(feature = "internal")]
pub async fn initialize_user_crypto(client: &mut Client, req: InitUserCryptoRequest) -> Result<()> {
    use crate::auth::{auth_request_decrypt_master_key, auth_request_decrypt_user_key};

    let login_method = crate::client::LoginMethod::User(crate::client::UserLoginMethod::Username {
        client_id: "".to_string(),
        email: req.email,
        kdf: req.kdf_params,
    });
    client.set_login_method(login_method);

    let private_key: EncString = req.private_key.parse()?;

    match req.method {
        InitUserCryptoMethod::Password { password, user_key } => {
            let user_key: EncString = user_key.parse()?;
            client.initialize_user_crypto(&password, user_key, private_key)?;
        }
        InitUserCryptoMethod::DecryptedKey { decrypted_user_key } => {
            let user_key = decrypted_user_key.parse::<SymmetricCryptoKey>()?;
            client.initialize_user_crypto_decrypted_key(user_key, private_key)?;
        }
        InitUserCryptoMethod::Pin {
            pin,
            pin_protected_user_key,
        } => {
            client.initialize_user_crypto_pin(&pin, pin_protected_user_key, private_key)?;
        }
        InitUserCryptoMethod::AuthRequest {
            request_private_key,
            method,
        } => {
            let user_key = match method {
                AuthRequestMethod::UserKey { protected_user_key } => {
                    auth_request_decrypt_user_key(request_private_key, protected_user_key)?
                }
                AuthRequestMethod::MasterKey {
                    protected_master_key,
                    auth_request_key,
                } => auth_request_decrypt_master_key(
                    request_private_key,
                    protected_master_key,
                    auth_request_key,
                )?,
            };
            client.initialize_user_crypto_decrypted_key(user_key, private_key)?;
        }
    }

    Ok(())
}

#[cfg(feature = "internal")]
#[derive(Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "mobile", derive(uniffi::Record))]
pub struct InitOrgCryptoRequest {
    /// The encryption keys for all the organizations the user is a part of
    pub organization_keys: HashMap<uuid::Uuid, AsymmetricEncString>,
}

#[cfg(feature = "internal")]
pub async fn initialize_org_crypto(client: &mut Client, req: InitOrgCryptoRequest) -> Result<()> {
    let organization_keys = req.organization_keys.into_iter().collect();
    client.initialize_org_crypto(organization_keys)?;
    Ok(())
}

#[cfg(feature = "internal")]
pub async fn get_user_encryption_key(client: &mut Client) -> Result<String> {
    let user_key = client
        .get_encryption_settings()?
        .get_key(&None)
        .ok_or(Error::VaultLocked)?;

    Ok(user_key.to_base64())
}

#[cfg(feature = "internal")]
#[derive(Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "mobile", derive(uniffi::Record))]
pub struct UpdatePasswordResponse {
    /// Hash of the new password
    password_hash: String,
    /// User key, encrypted with the new password
    new_key: EncString,
}

pub fn update_password(
    client: &mut Client,
    new_password: String,
) -> Result<UpdatePasswordResponse> {
    let user_key = client
        .get_encryption_settings()?
        .get_key(&None)
        .ok_or(Error::VaultLocked)?;

    let login_method = client
        .login_method
        .as_ref()
        .ok_or(Error::NotAuthenticated)?;

    // Derive a new master key from password
    let new_master_key = match login_method {
        LoginMethod::User(
            UserLoginMethod::Username { email, kdf, .. }
            | UserLoginMethod::ApiKey { email, kdf, .. },
        ) => MasterKey::derive(new_password.as_bytes(), email.as_bytes(), kdf)?,
        _ => return Err(Error::NotAuthenticated),
    };

    let new_key = new_master_key.encrypt_user_key(user_key)?;

    let password_hash = new_master_key.derive_master_key_hash(
        new_password.as_bytes(),
        bitwarden_crypto::HashPurpose::ServerAuthorization,
    )?;

    Ok(UpdatePasswordResponse {
        password_hash,
        new_key,
    })
}

#[cfg(feature = "internal")]
#[derive(Serialize, Deserialize, Debug, JsonSchema)]
#[serde(rename_all = "camelCase", deny_unknown_fields)]
#[cfg_attr(feature = "mobile", derive(uniffi::Record))]
pub struct DerivePinKeyResponse {
    /// [UserKey] protected by PIN
    pin_protected_user_key: EncString,
    /// PIN protected by [UserKey]
    encrypted_pin: EncString,
}

#[cfg(feature = "internal")]
pub fn derive_pin_key(client: &mut Client, pin: String) -> Result<DerivePinKeyResponse> {
    let user_key = client
        .get_encryption_settings()?
        .get_key(&None)
        .ok_or(Error::VaultLocked)?;

    let login_method = client
        .login_method
        .as_ref()
        .ok_or(Error::NotAuthenticated)?;

    let pin_protected_user_key = derive_pin_protected_user_key(&pin, login_method, user_key)?;

    Ok(DerivePinKeyResponse {
        pin_protected_user_key,
        encrypted_pin: pin.encrypt_with_key(user_key)?,
    })
}

#[cfg(feature = "internal")]
pub fn derive_pin_user_key(client: &mut Client, encrypted_pin: EncString) -> Result<EncString> {
    let user_key = client
        .get_encryption_settings()?
        .get_key(&None)
        .ok_or(Error::VaultLocked)?;

    let pin: String = encrypted_pin.decrypt_with_key(user_key)?;
    let login_method = client
        .login_method
        .as_ref()
        .ok_or(Error::NotAuthenticated)?;

    derive_pin_protected_user_key(&pin, login_method, user_key)
}

#[cfg(feature = "internal")]
fn derive_pin_protected_user_key(
    pin: &str,
    login_method: &LoginMethod,
    user_key: &SymmetricCryptoKey,
) -> Result<EncString> {
    let derived_key = match login_method {
        LoginMethod::User(
            UserLoginMethod::Username { email, kdf, .. }
            | UserLoginMethod::ApiKey { email, kdf, .. },
        ) => MasterKey::derive(pin.as_bytes(), email.as_bytes(), kdf)?,
        _ => return Err(Error::NotAuthenticated),
    };

    Ok(derived_key.encrypt_user_key(user_key)?)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{client::Kdf, Client};

    #[tokio::test]
    async fn test_update_password() {
        let mut client = Client::new(None);

        let priv_key = "2.kmLY8NJVuiKBFJtNd/ZFpA==|qOodlRXER+9ogCe3yOibRHmUcSNvjSKhdDuztLlucs10jLiNoVVVAc+9KfNErLSpx5wmUF1hBOJM8zwVPjgQTrmnNf/wuDpwiaCxNYb/0v4FygPy7ccAHK94xP1lfqq7U9+tv+/yiZSwgcT+xF0wFpoxQeNdNRFzPTuD9o4134n8bzacD9DV/WjcrXfRjbBCzzuUGj1e78+A7BWN7/5IWLz87KWk8G7O/W4+8PtEzlwkru6Wd1xO19GYU18oArCWCNoegSmcGn7w7NDEXlwD403oY8Oa7ylnbqGE28PVJx+HLPNIdSC6YKXeIOMnVs7Mctd/wXC93zGxAWD6ooTCzHSPVV50zKJmWIG2cVVUS7j35H3rGDtUHLI+ASXMEux9REZB8CdVOZMzp2wYeiOpggebJy6MKOZqPT1R3X0fqF2dHtRFPXrNsVr1Qt6bS9qTyO4ag1/BCvXF3P1uJEsI812BFAne3cYHy5bIOxuozPfipJrTb5WH35bxhElqwT3y/o/6JWOGg3HLDun31YmiZ2HScAsUAcEkA4hhoTNnqy4O2s3yVbCcR7jF7NLsbQc0MDTbnjxTdI4VnqUIn8s2c9hIJy/j80pmO9Bjxp+LQ9a2hUkfHgFhgHxZUVaeGVth8zG2kkgGdrp5VHhxMVFfvB26Ka6q6qE/UcS2lONSv+4T8niVRJz57qwctj8MNOkA3PTEfe/DP/LKMefke31YfT0xogHsLhDkx+mS8FCc01HReTjKLktk/Jh9mXwC5oKwueWWwlxI935ecn+3I2kAuOfMsgPLkoEBlwgiREC1pM7VVX1x8WmzIQVQTHd4iwnX96QewYckGRfNYWz/zwvWnjWlfcg8kRSe+68EHOGeRtC5r27fWLqRc0HNcjwpgHkI/b6czerCe8+07TWql4keJxJxhBYj3iOH7r9ZS8ck51XnOb8tGL1isimAJXodYGzakwktqHAD7MZhS+P02O+6jrg7d+yPC2ZCuS/3TOplYOCHQIhnZtR87PXTUwr83zfOwAwCyv6KP84JUQ45+DItrXLap7nOVZKQ5QxYIlbThAO6eima6Zu5XHfqGPMNWv0bLf5+vAjIa5np5DJrSwz9no/hj6CUh0iyI+SJq4RGI60lKtypMvF6MR3nHLEHOycRUQbZIyTHWl4QQLdHzuwN9lv10ouTEvNr6sFflAX2yb6w3hlCo7oBytH3rJekjb3IIOzBpeTPIejxzVlh0N9OT5MZdh4sNKYHUoWJ8mnfjdM+L4j5Q2Kgk/XiGDgEebkUxiEOQUdVpePF5uSCE+TPav/9FIRGXGiFn6NJMaU7aBsDTFBLloffFLYDpd8/bTwoSvifkj7buwLYM+h/qcnfdy5FWau1cKav+Blq/ZC0qBpo658RTC8ZtseAFDgXoQZuksM10hpP9bzD04Bx30xTGX81QbaSTNwSEEVrOtIhbDrj9OI43KH4O6zLzK+t30QxAv5zjk10RZ4+5SAdYndIlld9Y62opCfPDzRy3ubdve4ZEchpIKWTQvIxq3T5ogOhGaWBVYnkMtM2GVqvWV//46gET5SH/MdcwhACUcZ9kCpMnWH9CyyUwYvTT3UlNyV+DlS27LMPvaw7tx7qa+GfNCoCBd8S4esZpQYK/WReiS8=|pc7qpD42wxyXemdNPuwxbh8iIaryrBPu8f/DGwYdHTw=";

        let kdf = Kdf::PBKDF2 {
            iterations: 100_000.try_into().unwrap(),
        };

        initialize_user_crypto(
            &mut client,
            InitUserCryptoRequest {
                kdf_params: kdf.clone(),
                email: "test@bitwarden.com".into(),
                private_key: priv_key.to_owned(),
                method: InitUserCryptoMethod::Password {
                    password: "asdfasdfasdf".into(),
                    user_key: "2.u2HDQ/nH2J7f5tYHctZx6Q==|NnUKODz8TPycWJA5svexe1wJIz2VexvLbZh2RDfhj5VI3wP8ZkR0Vicvdv7oJRyLI1GyaZDBCf9CTBunRTYUk39DbZl42Rb+Xmzds02EQhc=|rwuo5wgqvTJf3rgwOUfabUyzqhguMYb3sGBjOYqjevc=".into(),
                },
            },
        )
        .await
        .unwrap();

        let new_password_response = update_password(&mut client, "123412341234".into()).unwrap();

        let mut client2 = Client::new(None);

        initialize_user_crypto(
            &mut client2,
            InitUserCryptoRequest {
                kdf_params: kdf.clone(),
                email: "test@bitwarden.com".into(),
                private_key: priv_key.to_owned(),
                method: InitUserCryptoMethod::Password {
                    password: "123412341234".into(),
                    user_key: new_password_response.new_key.to_string(),
                },
            },
        )
        .await
        .unwrap();

        let new_hash = client2
            .kdf()
            .hash_password(
                "test@bitwarden.com".into(),
                "123412341234".into(),
                kdf.clone(),
                bitwarden_crypto::HashPurpose::ServerAuthorization,
            )
            .await
            .unwrap();

        assert_eq!(new_hash, new_password_response.password_hash);

        assert_eq!(
            client
                .get_encryption_settings()
                .unwrap()
                .get_key(&None)
                .unwrap()
                .to_base64(),
            client2
                .get_encryption_settings()
                .unwrap()
                .get_key(&None)
                .unwrap()
                .to_base64()
        );
    }

    #[tokio::test]
    async fn test_initialize_user_crypto_pin() {
        let mut client = Client::new(None);

        let priv_key = "2.kmLY8NJVuiKBFJtNd/ZFpA==|qOodlRXER+9ogCe3yOibRHmUcSNvjSKhdDuztLlucs10jLiNoVVVAc+9KfNErLSpx5wmUF1hBOJM8zwVPjgQTrmnNf/wuDpwiaCxNYb/0v4FygPy7ccAHK94xP1lfqq7U9+tv+/yiZSwgcT+xF0wFpoxQeNdNRFzPTuD9o4134n8bzacD9DV/WjcrXfRjbBCzzuUGj1e78+A7BWN7/5IWLz87KWk8G7O/W4+8PtEzlwkru6Wd1xO19GYU18oArCWCNoegSmcGn7w7NDEXlwD403oY8Oa7ylnbqGE28PVJx+HLPNIdSC6YKXeIOMnVs7Mctd/wXC93zGxAWD6ooTCzHSPVV50zKJmWIG2cVVUS7j35H3rGDtUHLI+ASXMEux9REZB8CdVOZMzp2wYeiOpggebJy6MKOZqPT1R3X0fqF2dHtRFPXrNsVr1Qt6bS9qTyO4ag1/BCvXF3P1uJEsI812BFAne3cYHy5bIOxuozPfipJrTb5WH35bxhElqwT3y/o/6JWOGg3HLDun31YmiZ2HScAsUAcEkA4hhoTNnqy4O2s3yVbCcR7jF7NLsbQc0MDTbnjxTdI4VnqUIn8s2c9hIJy/j80pmO9Bjxp+LQ9a2hUkfHgFhgHxZUVaeGVth8zG2kkgGdrp5VHhxMVFfvB26Ka6q6qE/UcS2lONSv+4T8niVRJz57qwctj8MNOkA3PTEfe/DP/LKMefke31YfT0xogHsLhDkx+mS8FCc01HReTjKLktk/Jh9mXwC5oKwueWWwlxI935ecn+3I2kAuOfMsgPLkoEBlwgiREC1pM7VVX1x8WmzIQVQTHd4iwnX96QewYckGRfNYWz/zwvWnjWlfcg8kRSe+68EHOGeRtC5r27fWLqRc0HNcjwpgHkI/b6czerCe8+07TWql4keJxJxhBYj3iOH7r9ZS8ck51XnOb8tGL1isimAJXodYGzakwktqHAD7MZhS+P02O+6jrg7d+yPC2ZCuS/3TOplYOCHQIhnZtR87PXTUwr83zfOwAwCyv6KP84JUQ45+DItrXLap7nOVZKQ5QxYIlbThAO6eima6Zu5XHfqGPMNWv0bLf5+vAjIa5np5DJrSwz9no/hj6CUh0iyI+SJq4RGI60lKtypMvF6MR3nHLEHOycRUQbZIyTHWl4QQLdHzuwN9lv10ouTEvNr6sFflAX2yb6w3hlCo7oBytH3rJekjb3IIOzBpeTPIejxzVlh0N9OT5MZdh4sNKYHUoWJ8mnfjdM+L4j5Q2Kgk/XiGDgEebkUxiEOQUdVpePF5uSCE+TPav/9FIRGXGiFn6NJMaU7aBsDTFBLloffFLYDpd8/bTwoSvifkj7buwLYM+h/qcnfdy5FWau1cKav+Blq/ZC0qBpo658RTC8ZtseAFDgXoQZuksM10hpP9bzD04Bx30xTGX81QbaSTNwSEEVrOtIhbDrj9OI43KH4O6zLzK+t30QxAv5zjk10RZ4+5SAdYndIlld9Y62opCfPDzRy3ubdve4ZEchpIKWTQvIxq3T5ogOhGaWBVYnkMtM2GVqvWV//46gET5SH/MdcwhACUcZ9kCpMnWH9CyyUwYvTT3UlNyV+DlS27LMPvaw7tx7qa+GfNCoCBd8S4esZpQYK/WReiS8=|pc7qpD42wxyXemdNPuwxbh8iIaryrBPu8f/DGwYdHTw=";

        initialize_user_crypto(
            &mut client,
            InitUserCryptoRequest {
                kdf_params: Kdf::PBKDF2 {
                    iterations: 100_000.try_into().unwrap(),
                },
                email: "test@bitwarden.com".into(),
                private_key: priv_key.to_owned(),
                method: InitUserCryptoMethod::Password {
                    password: "asdfasdfasdf".into(),
                    user_key: "2.u2HDQ/nH2J7f5tYHctZx6Q==|NnUKODz8TPycWJA5svexe1wJIz2VexvLbZh2RDfhj5VI3wP8ZkR0Vicvdv7oJRyLI1GyaZDBCf9CTBunRTYUk39DbZl42Rb+Xmzds02EQhc=|rwuo5wgqvTJf3rgwOUfabUyzqhguMYb3sGBjOYqjevc=".into(),
                },
            },
        )
        .await
        .unwrap();

        let pin_key = derive_pin_key(&mut client, "1234".into()).unwrap();

        // Verify we can unlock with the pin
        let mut client2 = Client::new(None);
        initialize_user_crypto(
            &mut client2,
            InitUserCryptoRequest {
                kdf_params: Kdf::PBKDF2 {
                    iterations: 100_000.try_into().unwrap(),
                },
                email: "test@bitwarden.com".into(),
                private_key: priv_key.to_owned(),
                method: InitUserCryptoMethod::Pin {
                    pin: "1234".into(),
                    pin_protected_user_key: pin_key.pin_protected_user_key,
                },
            },
        )
        .await
        .unwrap();

        assert_eq!(
            client
                .get_encryption_settings()
                .unwrap()
                .get_key(&None)
                .unwrap()
                .to_base64(),
            client2
                .get_encryption_settings()
                .unwrap()
                .get_key(&None)
                .unwrap()
                .to_base64()
        );

        // Verify we can derive the pin protected user key from the encrypted pin
        let pin_protected_user_key =
            derive_pin_user_key(&mut client, pin_key.encrypted_pin).unwrap();

        let mut client3 = Client::new(None);

        initialize_user_crypto(
            &mut client3,
            InitUserCryptoRequest {
                kdf_params: Kdf::PBKDF2 {
                    iterations: 100_000.try_into().unwrap(),
                },
                email: "test@bitwarden.com".into(),
                private_key: priv_key.to_owned(),
                method: InitUserCryptoMethod::Pin {
                    pin: "1234".into(),
                    pin_protected_user_key,
                },
            },
        )
        .await
        .unwrap();

        assert_eq!(
            client
                .get_encryption_settings()
                .unwrap()
                .get_key(&None)
                .unwrap()
                .to_base64(),
            client3
                .get_encryption_settings()
                .unwrap()
                .get_key(&None)
                .unwrap()
                .to_base64()
        );
    }
}
