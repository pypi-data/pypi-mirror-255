# This file was auto-generated by Fern from our API Definition.

import typing
import urllib.parse
from json.decoder import JSONDecodeError

import httpx
import pydantic

from ...core.api_error import ApiError
from ...core.jsonable_encoder import jsonable_encoder
from ...core.remove_none_from_headers import remove_none_from_headers
from .errors.application_not_found_error import ApplicationNotFoundError
from .errors.application_slug_already_exists_error import ApplicationSlugAlreadyExistsError
from .errors.expired_token_error import ExpiredTokenError
from .errors.missing_fields_error import MissingFieldsError
from .errors.organization_not_found_error import OrganizationNotFoundError
from .errors.permission_denied_error import PermissionDeniedError
from .types.application import Application
from .types.application_id import ApplicationId
from .types.create_application_request import CreateApplicationRequest
from .types.create_upload_url_response import CreateUploadUrlResponse
from .types.deployment import Deployment
from .types.organization import Organization
from .types.organization_id import OrganizationId


class MarimoV1Client:
    def __init__(self, *, environment: str, token: str):
        self._environment = environment
        self._token = token

    def create_application(self, *, request: CreateApplicationRequest) -> Application:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "api/v1/applications"),
            json=jsonable_encoder(request),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Application, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 409:
            raise ApplicationSlugAlreadyExistsError()
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_applications(self, *, organization_id: OrganizationId) -> typing.List[Application]:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "api/v1/applications"),
            params={"organizationId": organization_id},
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Application], _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 404:
            raise OrganizationNotFoundError()
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_application(self, application_id: ApplicationId) -> Application:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", f"api/v1/applications/{application_id}"),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Application, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 404:
            raise ApplicationNotFoundError()
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_organizations(self) -> typing.List[Organization]:
        _response = httpx.request(
            "GET",
            urllib.parse.urljoin(f"{self._environment}/", "api/v1/organizations"),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Organization], _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_deployment(
        self,
        *,
        application_id: ApplicationId,
        code: str,
        requirements_txt: str,
        assets: typing.IO,
        version: typing.Optional[str] = None,
        app_entrypoint: typing.Optional[str] = None,
        python_version: typing.Optional[str] = None,
        cli_flags: typing.Optional[str] = None,
    ) -> Deployment:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "api/v1/deployments"),
            data=jsonable_encoder(
                {
                    "applicationId": application_id,
                    "code": code,
                    "requirementsTxt": requirements_txt,
                    "version": version,
                    "appEntrypoint": app_entrypoint,
                    "pythonVersion": python_version,
                    "cliFlags": cli_flags,
                }
            ),
            files={"assets": assets},
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Deployment, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 404:
            raise ApplicationNotFoundError()
        if _response.status_code == 400:
            raise MissingFieldsError(pydantic.parse_obj_as(typing.List[str], _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_upload_url(self, *, application_id: ApplicationId) -> CreateUploadUrlResponse:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "api/v1/deployments/upload-url"),
            json=jsonable_encoder({"applicationId": application_id}),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateUploadUrlResponse, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 404:
            raise ApplicationNotFoundError()
        if _response.status_code == 400:
            raise MissingFieldsError(pydantic.parse_obj_as(typing.List[str], _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_deployment_with_image(self, *, application_id: ApplicationId, image: str) -> Deployment:
        _response = httpx.request(
            "POST",
            urllib.parse.urljoin(f"{self._environment}/", "api/v1/deployments/image"),
            json=jsonable_encoder({"applicationId": application_id, "image": image}),
            headers=remove_none_from_headers(
                {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
            ),
            timeout=60,
        )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Deployment, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 404:
            raise ApplicationNotFoundError()
        if _response.status_code == 400:
            raise MissingFieldsError(pydantic.parse_obj_as(typing.List[str], _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncMarimoV1Client:
    def __init__(self, *, environment: str, token: str):
        self._environment = environment
        self._token = token

    async def create_application(self, *, request: CreateApplicationRequest) -> Application:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "api/v1/applications"),
                json=jsonable_encoder(request),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Application, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 409:
            raise ApplicationSlugAlreadyExistsError()
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_applications(self, *, organization_id: OrganizationId) -> typing.List[Application]:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", "api/v1/applications"),
                params={"organizationId": organization_id},
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Application], _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 404:
            raise OrganizationNotFoundError()
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_application(self, application_id: ApplicationId) -> Application:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", f"api/v1/applications/{application_id}"),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Application, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 404:
            raise ApplicationNotFoundError()
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_organizations(self) -> typing.List[Organization]:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "GET",
                urllib.parse.urljoin(f"{self._environment}/", "api/v1/organizations"),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(typing.List[Organization], _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_deployment(
        self,
        *,
        application_id: ApplicationId,
        code: str,
        requirements_txt: str,
        assets: typing.IO,
        version: typing.Optional[str] = None,
        app_entrypoint: typing.Optional[str] = None,
        python_version: typing.Optional[str] = None,
        cli_flags: typing.Optional[str] = None,
    ) -> Deployment:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "api/v1/deployments"),
                data=jsonable_encoder(
                    {
                        "applicationId": application_id,
                        "code": code,
                        "requirementsTxt": requirements_txt,
                        "version": version,
                        "appEntrypoint": app_entrypoint,
                        "pythonVersion": python_version,
                        "cliFlags": cli_flags,
                    }
                ),
                files={"assets": assets},
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Deployment, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 404:
            raise ApplicationNotFoundError()
        if _response.status_code == 400:
            raise MissingFieldsError(pydantic.parse_obj_as(typing.List[str], _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_upload_url(self, *, application_id: ApplicationId) -> CreateUploadUrlResponse:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "api/v1/deployments/upload-url"),
                json=jsonable_encoder({"applicationId": application_id}),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(CreateUploadUrlResponse, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 404:
            raise ApplicationNotFoundError()
        if _response.status_code == 400:
            raise MissingFieldsError(pydantic.parse_obj_as(typing.List[str], _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_deployment_with_image(self, *, application_id: ApplicationId, image: str) -> Deployment:
        async with httpx.AsyncClient() as _client:
            _response = await _client.request(
                "POST",
                urllib.parse.urljoin(f"{self._environment}/", "api/v1/deployments/image"),
                json=jsonable_encoder({"applicationId": application_id, "image": image}),
                headers=remove_none_from_headers(
                    {"Authorization": f"Bearer {self._token}" if self._token is not None else None}
                ),
                timeout=60,
            )
        if 200 <= _response.status_code < 300:
            return pydantic.parse_obj_as(Deployment, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise PermissionDeniedError(pydantic.parse_obj_as(str, _response.json()))  # type: ignore
        if _response.status_code == 401:
            raise ExpiredTokenError()
        if _response.status_code == 404:
            raise ApplicationNotFoundError()
        if _response.status_code == 400:
            raise MissingFieldsError(pydantic.parse_obj_as(typing.List[str], _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
