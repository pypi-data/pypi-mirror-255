"use strict";(self.webpackChunkskills_network_authoring_jupyterlab_extension=self.webpackChunkskills_network_authoring_jupyterlab_extension||[]).push([[496],{904:(o,e,t)=>{t.a(o,(async(o,n)=>{try{t.d(e,{CY:()=>a,Gq:()=>b,Mh:()=>r,U5:()=>c,Y$:()=>d,o7:()=>s,sd:()=>g,xy:()=>i});var l=t(8);const o=o=>{console.log("Retrieving server base URL...");let e=o.baseUrl;return e.endsWith("/")||(e+="/"),console.log(`Base URL is: ${e}`),e},a=await(async()=>{console.log("Attempting to fetch ATLAS_BASE_URL...");const e=window.location.href;console.log(`Current URL: ${e}`);const t=new URL(e).searchParams.get("atlas_base_url");if(null===t){console.log("ATLAS_BASE_URL not found in URL parameters, making server request...");const e={method:"GET"},t=l.ServerConnection.makeSettings(),n=o(t)+"skillsnetwork-authoring-extension/config";console.log(`Request URL for ATLAS_BASE_URL: ${n}`);const a=await l.ServerConnection.makeRequest(n,e,t),i=await a.json();return console.log(`Fetched ATLAS_BASE_URL: ${i.ATLAS_BASE_URL}`),i.ATLAS_BASE_URL}return console.log(`ATLAS_BASE_URL found in URL parameters: ${decodeURIComponent(t)}`),decodeURIComponent(t)})(),i=await(async()=>{console.log("Attempting to fetch AWB_BASE_URL...");const e=window.location.href;console.log(`Current URL: ${e}`);const t=new URL(e).searchParams.get("awb_base_url");if(null===t){console.log("AWB_BASE_URL not found in URL parameters, making server request...");const e={method:"GET"},t=l.ServerConnection.makeSettings(),n=o(t)+"skillsnetwork-authoring-extension/config";console.log(`Request URL for AWB_BASE_URL: ${n}`);const a=await l.ServerConnection.makeRequest(n,e,t),i=await a.json();return console.log(`Fetched AWB_BASE_URL: ${i.AWB_BASE_URL}`),i.AWB_BASE_URL}return console.log(`AWB_BASE_URL found in URL parameters: ${decodeURIComponent(t)}`),decodeURIComponent(t)})(),s=await(async()=>{const e=window.location.href,t=new URL(e).searchParams.get("sn_file_library_url");if(null===t){const e={method:"GET"},t=l.ServerConnection.makeSettings(),n=o(t)+"skillsnetwork-authoring-extension/config",a=await l.ServerConnection.makeRequest(n,e,t);return(await a.json()).SN_FILE_LIBRARY_URL}return decodeURIComponent(t)})(),r=async()=>{console.log("Determining mode...");const o=window.location.href,e=new URL(o).searchParams.get("mode");return"learn"===e?e:"author"},c=async()=>{console.log("Extracting Atlas token from URL query...");const o=window.location.href,e=new URL(o).searchParams.get("atlas_token");return null!==e?e:"NO_TOKEN"},d=async()=>{console.log("Extracting AWB token from URL query...");const o=window.location.href,e=new URL(o).searchParams.get("awb_token");return null!==e?e:"NO_TOKEN"},g=async()=>{console.log("Setting default lab name and kernel...");const o=window.location.href;let e=new URL(o).searchParams.get("env_type");return"jupyterlab"!==e&&"jupyterlite"!==e&&(e="local"),console.log("Env type: ",e),"jupyterlab"===e||"local"===e?(b.PY_KERNEL_NAME=await u(),b.DEFAULT_LAB_NAME="lab.ipynb"):"jupyterlite"===e&&(b.PY_KERNEL_NAME="python",b.DEFAULT_LAB_NAME="lab.jupyterlite.ipynb"),e},u=async()=>{console.log("Getting Python kernel...");const o=await(await l.KernelSpecAPI.getSpecs()).kernelspecs,e=Object.keys(o).filter((function(o){return o.includes("python")})).sort();return e[e.length-1]};class b{}b.TOKENS=new Map,b.SHOW_PUBLISH_BUTTON_FOR=void 0,b.PREV_PUB_HASH="prev_pub_hash",b.BACKUP_EXT=".backup",n()}catch(o){n(o)}}),1)},399:(o,e,t)=>{t.d(e,{E3:()=>i,KQ:()=>d,Sc:()=>s,WA:()=>r,Zm:()=>g,g3:()=>c});var n=t(760),l=t(908);class a extends n.Widget{constructor(){console.log("Initializing SpinnerDialog...");const o=document.createElement("div"),e=new l.Spinner;o.appendChild(e.node),o.style.padding="15px",super({node:o})}}const i=o=>{console.log(`Showing spinner with message: ${o}`);const e=new a;(0,l.showDialog)({title:o,body:e,buttons:[l.Dialog.cancelButton()]}).then((o=>{"Cancel"===o.button.label&&console.log("Spinner dialog cancelled by user")}))},s=o=>{console.log(`Showing standalone spinner with message: ${o}`);const e=new a;return(0,l.showDialog)({title:o,body:e,buttons:[]}).then((o=>(console.log("Standalone spinner dialog closed"),o)))},r=o=>(console.log(`Showing confirmation dialog with message: ${o}`),(0,l.showDialog)({title:o,body:"Are you sure you want to publish? This action is not reversible",buttons:[l.Dialog.okButton(),l.Dialog.cancelButton()]}).then((o=>{if(!o.button.accept)throw console.log("Operation cancelled by the user."),new Error("Operation cancelled by the user.");console.log("Operation confirmed by the user.")}))),c=()=>{console.log("Showing success publish dialog"),(0,l.showDialog)({title:"Success!",body:"This lab has been successfully published!",buttons:[l.Dialog.okButton()]}).then((o=>{console.log("Success dialog closed by user")})).catch((o=>{console.log("Error closing success dialog:",o)}))},d=()=>{console.log("Showing failure to publish dialog"),(0,l.showDialog)({title:"Failed to Publish",body:"This lab failed to publish.",buttons:[l.Dialog.okButton()]}).then((o=>{console.log("Failure dialog closed by user")})).catch((o=>{console.log("Error closing failure dialog:",o)}))},g=()=>{console.log("Showing failure to load lab dialog"),(0,l.showDialog)({title:"Failed to Load Lab",body:"This lab failed to load.",buttons:[l.Dialog.okButton()]}).then((o=>{console.log("Failure to load lab dialog closed by user")})).catch((o=>{console.log("Error closing failure to load lab dialog:",o)}))}},480:(o,e,t)=>{t.a(o,(async(o,n)=>{try{t.d(e,{CU:()=>w,E$:()=>k,I7:()=>m,Yj:()=>f,aK:()=>p,m:()=>y});var l=t(637),a=t.n(l),i=t(399),s=t(908),r=t(904),c=t(96),d=t(500),g=t.n(d),u=t(416),b=t.n(u),h=o([r,c]);[r,c]=h.then?(await h)():h;const p=o=>(console.log("Creating axios instance with ATLAS_BASE_URL"),g().create({baseURL:r.CY,headers:{Authorization:`Bearer ${o}`,"Content-Type":"application/json","Access-Control-Allow-Origin":"*",Accept:"application/json"}})),w=o=>(console.log("Creating axios instance with AWB_BASE_URL"),g().create({baseURL:r.xy,headers:{Authorization:`Bearer ${o}`,"Content-Type":"application/json","Access-Control-Allow-Origin":"*",Accept:"application/json"}})),f=async(o,e)=>{try{console.log("Decoding JWT for lab_token");const t=b()(e),n=t.version_id,l=t.lab_id;console.log(`Fetching lab model for lab_id: ${l}, version_id: ${n}`);const a=`${t.lab_name}.ipynb`,i=await o.get(`api/v1/labs/${l}/lab_versions/${n}/download`).then((o=>(console.log("Lab model fetched successfully"),o.data)));return s.Dialog.flush(),console.log("Returning fetched lab model"),{labFilename:a,body:i}}catch(o){throw console.log("Error fetching lab model:",o),"Failed to fetch notebook"}},m=async(o,e,t,n)=>{if(console.log("Showing confirmation status dialog"),!await(0,i.WA)("Publishing your lab onto Skills Network...").then((o=>!0)).catch((o=>!1)))return void console.log("Confirmation status: Cancelled by user");console.log("Confirmation status: Confirmed"),(0,i.Sc)("Publishing your changes..."),console.log("Decoding JWT for lab_token");const l=b()(n),r=l.version_id,d=l.lab_id;console.log("Updating lab commit ID"),await(0,c.ol)(e,t),console.log("Fetching current file contents");const g=await(0,c.gv)(e,t);console.log("Creating FormData for POST request");const u=new(a());return u.append("publish","true"),u.append("draft[changelog]","updated notebook"),u.append("file",g),console.log(`Posting lab model to AWB for lab_id: ${d}, version_id: ${r}`),new Promise((async(e,t)=>{await o.post(`api/v1/labs/${d}/lab_versions/${r}/drafts`,u).then((o=>{console.log("SUCCESSFULLY PUSHED",o),s.Dialog.flush(),(0,i.g3)(),e()})).catch((o=>{console.log("Error pushing lab model:",o),s.Dialog.flush(),(0,i.KQ)(),t(new Error("Failed to post lab model"))}))}))},y=o=>(console.log("Fetching lab model from ATLAS"),o.get("v1/labs").then((o=>(console.log("Lab model fetched successfully from ATLAS"),s.Dialog.flush(),o.data))).catch((o=>{throw console.log("Error fetching lab model from ATLAS:",o),"Failed to fetch notebook"}))),k=async(o,e,t)=>{if(console.log("Showing confirmation status dialog"),!await(0,i.WA)("Publishing your lab onto Skills Network...").then((o=>!0)).catch((o=>!1)))return void console.log("Confirmation status: Cancelled by user");console.log("Confirmation status: Confirmed"),(0,i.Sc)("Publishing your changes..."),console.log("Updating lab commit ID"),await(0,c.ol)(e,t),console.log("Fetching current file contents");const n=await(0,c.gv)(e,t);return console.log("Posting lab model to ATLAS"),new Promise((async(e,t)=>{await o.post("v1/labs",{body:n}).then((o=>{console.log("SUCCESSFULLY PUSHED to ATLAS",o),s.Dialog.flush(),(0,i.g3)(),e()})).catch((o=>{console.log("Error pushing lab model to ATLAS:",o),s.Dialog.flush(),(0,i.KQ)(),t(new Error("Failed to post lab model to ATLAS"))}))}))};n()}catch(o){n(o)}}))},496:(o,e,t)=>{t.a(o,(async(o,n)=>{try{t.r(e),t.d(e,{default:()=>r});var l=t(964),a=t(808),i=o([l,a]);[l,a]=i.then?(await i)():i,console.log("Initializing JupyterFrontEnd plugins for the extension.");const s=[l.c,a.c];console.log("JupyterFrontEnd plugins defined:",s.map((o=>o.id)));const r=s;n()}catch(o){n(o)}}))},964:(o,e,t)=>{t.a(o,(async(o,n)=>{try{t.d(e,{c:()=>h});var l=t(908),a=t(760),i=t(896),s=t(780),r=t(399),c=t(904),d=t(96),g=t(416),u=t.n(g),b=o([c,d]);[c,d]=b.then?(await b)():b;const h={id:"skills_network_authoring_jupyterlab_extension:menu",autoStart:!0,requires:[l.ICommandPalette,i.INotebookTracker,s.IDocumentManager],activate:async(o,e,t,n)=>{if(console.log("skills_network_authoring_jupyterlab_extension:menu extension activated"),"learn"===await(0,c.Mh)())return void console.log('The current mode is "learn". The menu will not be activated.');const{commands:l}=o,a="mainMenu:editLabFromToken";l.addCommand(a,{label:"Edit a Lab",execute:e=>{console.log("Executing editLabFromToken command..."),p(0,n,o.serviceManager.contents)}}),e.addItem({command:a,category:"skillsNetwork",args:{origin:"from the palette"}})}};function p(o,e,t){console.log("Showing token dialog for editing a lab...");const n=document.createElement("div"),i=document.createElement("label");i.textContent="Enter your authorization token";const s=document.createElement("input");s.className="jp-mod-styled",n.appendChild(i),n.appendChild(s),(0,l.showDialog)({title:"Edit a Lab",body:new a.Widget({node:n}),buttons:[l.Dialog.cancelButton(),l.Dialog.okButton()]}).then((async o=>{if(o.button.accept){console.log("Token dialog accepted, loading lab..."),(0,r.E3)("Loading up your lab...");const o=s.value;console.log(`Token received: ${o.substring(0,15)}...`),"version_id"in u()(o)?(console.log("Token contains version_id, opening independent lab..."),await(0,d.op)(o,e,t)):(console.log("Token does not contain version_id, opening lab..."),await(0,d.UJ)(o,e,t))}else console.log("Token dialog canceled by the user.")})).catch((o=>{l.Dialog.flush(),(0,r.Zm)(),console.error("Error occurred while importing lab:",o)}))}n()}catch(w){n(w)}}))},864:(o,e,t)=>{t.a(o,(async(o,n)=>{try{t.d(e,{q:()=>b});var l=t(760),a=t(908),i=t(904),s=t(416),r=t.n(s),c=o([i]);i=(c.then?(await c)():c)[0];var d,g=function(o,e,t,n){if("a"===t&&!n)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof e?o!==e||!n:!e.has(o))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===t?n:"a"===t?n.call(o):n?n.value:e.get(o)};class u extends l.Widget{constructor(o){console.log(`Creating SkillsNetworkFileLibraryWidget with nbPanelId: ${o}`);const e=document.createElement("iframe"),t=i.Gq.TOKENS.get(o);console.log(`Retrieved token for nbPanelId ${o}: ${t}`);const n=t?r()(t):{};console.log("Decoded token info:",n),"project_id"in n&&(e.src=`${i.o7}?atlas_token=${t}`,console.log(`Setting iframe src to ${e.src}`)),e.setAttribute("frameborder","0"),e.setAttribute("allow","clipboard-read; clipboard-write"),e.classList.add("sn-file-library-frame"),super({node:e}),console.log("SkillsNetworkFileLibraryWidget created.")}}class b{constructor(o){d.set(this,void 0),console.log(`Initializing SkillsNetworkFileLibrary with nbPanelId: ${o}`),function(o,e,t,n,l){if("m"===n)throw new TypeError("Private method is not writable");if("a"===n&&!l)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof e?o!==e||!l:!e.has(o))throw new TypeError("Cannot write private member to an object whose class did not declare it");"a"===n?l.call(o,t):l?l.value=t:e.set(o,t)}(this,d,o,"f")}launch(){console.log(`Launching SkillsNetworkFileLibrary dialog for nbPanelId: ${g(this,d,"f")}`);const o=new a.Dialog({title:"Skills Network File Library",body:new u(g(this,d,"f")),hasClose:!0,buttons:[]});console.log("SkillsNetworkFileLibrary dialog created.");const e=o.node.querySelector(".jp-Dialog-content");e&&(e.classList.add("sn-file-library-dialog"),console.log("Added 'sn-file-library-dialog' class to dialog content.")),o.launch().then((()=>{console.log("SkillsNetworkFileLibrary dialog launched.")})).catch((o=>{console.error("Error launching SkillsNetworkFileLibrary dialog:",o)}))}}d=new WeakMap,n()}catch(o){n(o)}}))},808:(o,e,t)=>{t.a(o,(async(o,n)=>{try{t.d(e,{c:()=>k});var l=t(780),a=t(908),i=t(96),s=t(508),r=t(480),c=t(399),d=t(904),g=t(416),u=t.n(g),b=t(896),h=t(864),p=o([d,r,i,h]);[d,r,i,h]=p.then?(await p)():p;const w={id:"skills_network_authoring_jupyterlab_extension:toolbar",description:"Toolbar plugin for Skills Network Authoring Extension",autoStart:!0,requires:[b.INotebookTracker,l.IDocumentManager],activate:y};async function f(o){console.log("[cleanUpEnvironment] Cleaning up environment by closing all opened notebook widgets."),o.forEach((o=>{o.dispose()}))}class m{createNew(o,e){if(console.log(`[ButtonExtension] createNew invoked for notebook: ${e.path}`),d.Gq.SHOW_PUBLISH_BUTTON_FOR!==e.path)return console.log("[ButtonExtension] No publish button due to context path mismatch."),new s.DisposableDelegate((()=>{}));{const t=async()=>{console.log("[ButtonExtension] Publish button clicked.");const t=e.path.split("/").pop()||"",n=d.Gq.TOKENS.get(t);if(void 0===n)return console.log(`[ButtonExtension] No token found for filename: ${t}`),void await(0,a.showDialog)({title:"Publishing Restricted",body:`Only the lab '${d.Gq.TOKENS.keys().next().value}' can be published during this editing session.`,buttons:[a.Dialog.okButton({label:"Dismiss"})]});console.log(`[ButtonExtension] Token found for filename: ${t}, proceeding with lab model post.`),"version_id"in u()(n)?await(0,r.I7)((0,r.CU)(n),o,e,n):await(0,r.E$)((0,r.aK)(n),o,e)},n=async()=>{console.log("[ButtonExtension] Download button clicked.");const t=await(0,i.gv)(o,e),n=new Blob([t],{type:"application/x-ipynb+json"}),l=URL.createObjectURL(n),a=document.createElement("a");a.setAttribute("download",e.path),a.setAttribute("href",l),document.body.appendChild(a),a.click(),document.body.removeChild(a),URL.revokeObjectURL(l)},l=new a.ToolbarButton({className:"download-lab-button",label:"Download Notebook",onClick:n,tooltip:"Download the current notebook ipynb file to your local system"}),c=new a.ToolbarButton({className:"publish-lab-button",label:"Publish on SN",onClick:t,tooltip:"Publish Lab"}),g=new a.ToolbarButton({className:"sn-file-library-button",label:"SN File Library",onClick:()=>{console.log("[ButtonExtension] SN File Library button clicked."),new h.q(o.id).launch()},tooltip:"Skills Network File Library"});return console.log("[ButtonExtension] Adding buttons to notebook toolbar."),o.toolbar.insertItem(8,"download",l),o.toolbar.insertItem(9,"sn-file-library",g),o.toolbar.insertItem(10,"publish",c),new s.DisposableDelegate((()=>{console.log("[ButtonExtension] Disposing buttons from notebook toolbar."),l.dispose(),c.dispose(),g.dispose()}))}}}async function y(o,e,t){if(console.log("Activating skillsnetwork-authoring-extension button plugin!"),"learn"===await(0,d.Mh)())return void console.log('[activate] Mode is "learn", not activating plugin.');console.log("[activate] Initializing globals and attempting to open lab...");const n=await(0,d.U5)(),l=await(0,d.Y$)(),s=await(0,d.sd)();console.log("Using default kernel: ",d.Gq.PY_KERNEL_NAME),console.log("[activate] Environment type set, adding widget extension."),console.log("skills_network_authoring_jupyterlab_extension:toolbar extension activated"),o.docRegistry.addWidgetExtension("Notebook",new m),await o.serviceManager.ready,o.restored.then((async()=>{if(console.log("[activate] App restored, cleaning up environment."),await f(e),"NO_TOKEN"!==n&&"local"!==s)try{console.log("[activate] Opening lab with Atlas token."),await(0,i.UJ)(n,t,o.serviceManager.contents)}catch(o){console.error("[activate] Error opening lab with Atlas token:",o),a.Dialog.flush(),(0,c.Zm)()}else if("NO_TOKEN"!==l&&"local"!==s)try{console.log("[activate] Opening lab with AWB token."),await(0,i.op)(l,t,o.serviceManager.contents)}catch(o){console.error("[activate] Error opening lab with AWB token:",o),a.Dialog.flush(),(0,c.Zm)()}})),console.log("[activate] Plugin activated successfully.")}const k=w;n()}catch(v){n(v)}}))},96:(o,e,t)=>{t.a(o,(async(o,n)=>{try{t.d(e,{UJ:()=>w,gv:()=>d,ol:()=>g,op:()=>p});var l=t(908),a=t(904),i=t(480),s=o([a,i]);[a,i]=s.then?(await s)():s;const r=o=>{console.log(`Getting contents for cell with id: ${o.model.id}`);const e=o.model.toJSON().source,t="string"==typeof e?[e]:e;return{cell_type:o.model.type,id:o.model.id,metadata:{},outputs:[],source:t}},c=o=>{console.log(`Getting contents for cell with id: ${o.model.id}, omitting ID`);const e=o.model.toJSON().source,t="string"==typeof e?[e]:e;return{cell_type:o.model.type,id:"",metadata:{},outputs:[],source:t}},d=(o,e)=>{console.log(`Extracting file contents from notebook: ${e.path}`);const t=[];o.content.widgets.forEach((o=>{const e=r(o);t.push(e)}));const n={kernelspec:e.model.getMetadata("kernelspec"),language_info:e.model.getMetadata("language_info"),orig_nbformat:e.model.getMetadata("orig_nbformat"),[a.Gq.PREV_PUB_HASH]:e.model.getMetadata(a.Gq.PREV_PUB_HASH)};console.log(`Retrived notebook metadata: ${n}`);const l=e.model.nbformat,i=e.model.nbformatMinor,s={cells:t,metadata:n,nbformat:l,nbformat_minor:i};return console.log(`File contents extracted: ${JSON.stringify(s).substring(0,50)}...`),JSON.stringify(s,null,2)};async function g(o,e){console.log(`Updating commit ID for notebook: ${e.path}`);const t=await h(o,e),n=await A(t);console.log(`Generated commit ID: ${n}`),await e.ready,e.model.setMetadata(a.Gq.PREV_PUB_HASH,n),console.log(`Set commit ID in notebook metadata: ${a.Gq.PREV_PUB_HASH}: ${n}`),e.save().then((()=>{console.log("Notebook saved with updated commit ID.")})).catch((o=>{console.error("Failed to save notebook with updated commit ID:",o)}))}function u(o){var e,t,n,l,i,s,r;return console.log("Retrieving lab commit ID..."),"string"==typeof o&&(o=JSON.parse(o)),"object"!=typeof o||null===o||!("metadata"in o)&&!("content"in o)?(console.error("Lab content is of unknown type: ",typeof o,"\n Value: \n",o),""):null!==(r=null!==(n=null===(t=null===(e=o.metadata)||void 0===e?void 0:e[a.Gq.PREV_PUB_HASH])||void 0===t?void 0:t.toString())&&void 0!==n?n:null===(s=null===(i=null===(l=o.content)||void 0===l?void 0:l.metadata)||void 0===i?void 0:i[a.Gq.PREV_PUB_HASH])||void 0===s?void 0:s.toString())&&void 0!==r?r:""}function b(o){var e;if(console.log("Checking if lab content is blank..."),"string"==typeof o)try{o=JSON.parse(o)}catch(o){return console.error("Error parsing lab content string:",o),!1}if("object"!=typeof o||null===o||!("cells"in o)&&(!o.content||!("cells"in o.content)))return console.error("Lab content is of unknown type or missing 'cells': ",typeof o,"\n Value: \n",o),!1;const t=o.cells||(null===(e=o.content)||void 0===e?void 0:e.cells);return 0===t.length||1===t.length&&0===t[0].source.length}const h=(o,e)=>{console.log("[getFileCellContentsOmitID] Extracting cell contents, omitting IDs.");const t=[];return o.content.widgets.forEach((o=>{const e=c(o);t.push(e)})),console.log("[getFileCellContentsOmitID] Cell contents extracted."),JSON.stringify(t,null,2)},p=async(o,e,t)=>{console.log("[openIndependentLab] Opening independent lab with AWB token.");const{labFilename:n,body:l}=await(0,i.Yj)((0,i.CU)(o),o);let s;if(await m(n,t,e),await f(n,l,t,e),a.Gq.SHOW_PUBLISH_BUTTON_FOR=n,a.Gq.TOKENS.set(n,o),await v(`./${n}`,t))console.log("[openIndependentLab] Opening existing notebook."),s=e.openOrReveal(n);else{if(console.log("[openIndependentLab] No previous file found, creating new notebook."),s=e.createNew(n,"notebook",{name:a.Gq.PY_KERNEL_NAME}),void 0===s)throw Error("Error loading lab");await y(s,l)}return console.log("[openIndependentLab] Independent lab opened successfully."),s},w=async(o,e,t)=>{console.log("[openLab] Opening lab with token.");const{instructions_file_path:n,body:l}=await(0,i.m)((0,i.aK)(o)),s=k(n);let r;if(await m(s,t,e),await f(s,l,t,e),a.Gq.SHOW_PUBLISH_BUTTON_FOR=s,a.Gq.TOKENS.set(s,o),await v(`./${s}`,t))console.log("[openLab] Opening existing notebook."),r=e.openOrReveal(s);else{if(console.log("[openLab] No previous file found, creating new notebook."),r=e.createNew(s,"notebook",{name:a.Gq.PY_KERNEL_NAME}),void 0===r)throw Error("Error loading lab");await y(r,JSON.parse(l))}return console.log("[openLab] Lab opened successfully."),r};async function f(o,e,t,n){console.log("[checkAndBackupSaveFile] Checking for and backing up save file.");const i=`./${o}`,s=await v(i,t);if(s&&u(e)!==u(s)){console.log("[checkAndBackupSaveFile] Commit ID mismatch, converting file to backup.");try{await S(s,t,n),await(0,l.showDialog)({title:"Your Lab was Updated",body:`The newest published version of "${o}" is loaded. Your previous version has been backed up under "${o}${a.Gq.BACKUP_EXT}.ipynb"`,buttons:[l.Dialog.okButton({label:"Dismiss"})]}),console.log("[checkAndBackupSaveFile] Lab was updated successfully")}catch(e){console.error("[checkAndBackupSaveFile] Error during file backup",e),await(0,l.showDialog)({title:"Error with Previous File",body:`While trying to load your lab: "${o}", we found that you have another file named "${o}" that already exists in this folder, please delete it or rename it so we can load your published version"`,buttons:[l.Dialog.okButton({label:"Dismiss"})]})}}}async function m(o,e,t){console.log("[deleteIfEmptyFile] Checking if file is empty to delete.");const n=`./${o}`,l=await v(n,e);l&&(console.log("[deleteIfEmptyFile] File found, checking if it's empty."),await E(n,t),b(l)&&(console.log("[deleteIfEmptyFile] File is empty, deleting."),await e.delete(n)))}const y=async(o,e,t)=>{if(console.log("[loadLabContents] Loading lab contents."),await o.context.ready,"local"!==t){console.log("[loadLabContents] Authoring environment is not local, loading content."),o.context.model.fromJSON(e);try{await o.context.save(),console.log("[loadLabContents] Lab contents loaded and saved.")}catch(o){console.error("[loadLabContents] Error saving notebook:",o)}}else console.error("[loadLabContents] Notebook model is not initialized or authoring environment is local.")},k=o=>(console.log("[getLabFileName] Getting lab file name."),(null!=o?o:a.Gq.DEFAULT_LAB_NAME).replace(/^.*[\\/]/,""));async function v(o,e){console.log(`[getFile] Attempting to get file: ${o}`);try{const t=await e.get(o);return console.log(`[getFile] Successfully retrieved file: ${o}`),t}catch(e){if(console.log(`[getFile] Error retrieving file: ${o}`,e),e instanceof Error){const t=e;if(t.response&&404!==t.response.status)throw console.error("Error checking for existent backup file: ",e),e;return console.log("[getFile] File not found, returning null:",o),null}throw console.error("[getFile] Unexpected error type:",e),e}}async function _(o,e){const t=e.findWidget(o);if(t)try{t.context.model.dirty&&(console.log(`[saveAndCloseOpenFiles] Saving dirty widget for path: ${o}`),await t.context.save()),console.log(`[saveAndCloseOpenFiles] Closing widget for path: ${o}`),t.close()}catch(o){console.error("[saveAndCloseOpenFiles] Error saving or closing widget:",o)}else console.log(`[saveAndCloseOpenFiles] No open widget found for path: ${o}`)}async function E(o,e){console.log(`[closeWithoutSaving] Attempting to close without saving for path: ${o}`);const t=e.findWidget(o);if(t)try{const n=e.contextForWidget(t);n&&n.model&&(n.model.dirty=!1,console.log(`[closeWithoutSaving] Marked context as not dirty for path: ${o}`)),t.close(),console.log(`[closeWithoutSaving] Widget closed for path: ${o}`)}catch(o){console.error("[closeWithoutSaving] Error closing widget:",o)}else console.log(`[closeWithoutSaving] No open widget found for path: ${o}`)}async function S(o,e,t){console.log(`[convertFileToBackup] Attempting to convert file to backup for path: ${o.path}`);const n=o.path,l=n.split(".").pop(),i=`${n.replace(/\.[^/.]+$/,"")}${a.Gq.BACKUP_EXT}.${l}`;if(console.log(`[convertFileToBackup] New path for backup: ${i}`),await v(i,e)){console.log(`[convertFileToBackup] Previous backup file exists, deleting: ${i}`);try{await e.delete(i)}catch(o){console.error("[convertFileToBackup] Error deleting existing backup file:",o)}}try{await _(n,t),await e.rename(n,i),console.log(`[convertFileToBackup] File successfully renamed to backup: ${i}`)}catch(o){console.error("[convertFileToBackup] Error renaming file to backup:",o)}}async function A(o){console.log("[generateHash] Generating hash for data");const e=(new TextEncoder).encode(o),t=await crypto.subtle.digest("SHA-256",e),n=Array.from(new Uint8Array(t)).map((o=>o.toString(16).padStart(2,"0"))).join("");return console.log("[generateHash] Hash generated successfully"),n}n()}catch(L){n(L)}}))}}]);