
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    SubClassValueT as _SubClassValueT,
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "iree_linalg_ext"
  pass


@_ods_cext.register_operation(_Dialect)
class AttentionOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.attention"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, inputs, outputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def attention(results_, inputs, outputs, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(AttentionOp(results_=results_, inputs=inputs, outputs=outputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class DoNotDCEOperandsOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.transform.do_not_dce_operands"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def transform_do_not_dce_operands(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(DoNotDCEOperandsOp(operands_=operands_, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class FftOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.fft"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, inputs, outputs, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def fft(results_, inputs, outputs, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(FftOp(results_=results_, inputs=inputs, outputs=outputs, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PackOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.pack"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,0,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, inputs, outputs, inner_dims_pos, inner_tiles, static_inner_tiles, *, outer_dims_perm=None, padding_value=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    operands.append(_get_op_results_or_values(inner_tiles))
    operands.append(_get_op_result_or_value(padding_value) if padding_value is not None else None)
    _ods_context = _ods_get_default_loc_context(loc)
    if outer_dims_perm is not None: attributes["outer_dims_perm"] = (outer_dims_perm if (
        issubclass(type(outer_dims_perm), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(outer_dims_perm, context=_ods_context))
    attributes["inner_dims_pos"] = (inner_dims_pos if (
    issubclass(type(inner_dims_pos), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(inner_dims_pos, context=_ods_context))
    attributes["static_inner_tiles"] = (static_inner_tiles if (
    issubclass(type(static_inner_tiles), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_inner_tiles, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def inner_tiles(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def padding_value(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 3)
    return operand_range[0] if len(operand_range) > 0 else None

  @builtins.property
  def outer_dims_perm(self):
    if "outer_dims_perm" not in self.operation.attributes:
      return None
    return self.operation.attributes["outer_dims_perm"]

  @outer_dims_perm.setter
  def outer_dims_perm(self, value):
    if value is not None:
      self.operation.attributes["outer_dims_perm"] = value
    elif "outer_dims_perm" in self.operation.attributes:
      del self.operation.attributes["outer_dims_perm"]

  @outer_dims_perm.deleter
  def outer_dims_perm(self):
    del self.operation.attributes["outer_dims_perm"]

  @builtins.property
  def inner_dims_pos(self):
    return self.operation.attributes["inner_dims_pos"]

  @inner_dims_pos.setter
  def inner_dims_pos(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inner_dims_pos"] = value

  @builtins.property
  def static_inner_tiles(self):
    return self.operation.attributes["static_inner_tiles"]

  @static_inner_tiles.setter
  def static_inner_tiles(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_inner_tiles"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def pack(results_, inputs, outputs, inner_dims_pos, inner_tiles, static_inner_tiles, *, outer_dims_perm=None, padding_value=None, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(PackOp(results_=results_, inputs=inputs, outputs=outputs, inner_dims_pos=inner_dims_pos, inner_tiles=inner_tiles, static_inner_tiles=static_inner_tiles, outer_dims_perm=outer_dims_perm, padding_value=padding_value, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ReverseOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.reverse"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, inputs, outputs, dimensions, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimensions"] = (dimensions if (
    issubclass(type(dimensions), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64ElementsAttr')) else
      _ods_ir.AttrBuilder.get('I64ElementsAttr')(dimensions, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def dimensions(self):
    return self.operation.attributes["dimensions"]

  @dimensions.setter
  def dimensions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimensions"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def reverse(results_, inputs, outputs, dimensions, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(ReverseOp(results_=results_, inputs=inputs, outputs=outputs, dimensions=dimensions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ScanOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.scan"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, outputs, dimension, inclusive, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    issubclass(type(dimension), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    attributes["inclusive"] = (inclusive if (
    issubclass(type(inclusive), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('BoolAttr')) else
      _ods_ir.AttrBuilder.get('BoolAttr')(inclusive, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def inclusive(self):
    return self.operation.attributes["inclusive"]

  @inclusive.setter
  def inclusive(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inclusive"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self):
    return self.regions[0]

def scan(results_, inputs, outputs, dimension, inclusive, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(ScanOp(results_=results_, inputs=inputs, outputs=outputs, dimension=dimension, inclusive=inclusive, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ScatterOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.scatter"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, outputs, dimension_map, *, unique_indices=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension_map"] = (dimension_map if (
    issubclass(type(dimension_map), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(dimension_map, context=_ods_context))
    if unique_indices is not None: attributes["unique_indices"] = (unique_indices if (
        issubclass(type(unique_indices), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('BoolAttr')) else
          _ods_ir.AttrBuilder.get('BoolAttr')(unique_indices, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def dimension_map(self):
    return self.operation.attributes["dimension_map"]

  @dimension_map.setter
  def dimension_map(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension_map"] = value

  @builtins.property
  def unique_indices(self):
    return self.operation.attributes["unique_indices"]

  @unique_indices.setter
  def unique_indices(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["unique_indices"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self):
    return self.regions[0]

def scatter(results_, inputs, outputs, dimension_map, *, unique_indices=None, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(ScatterOp(results_=results_, inputs=inputs, outputs=outputs, dimension_map=dimension_map, unique_indices=unique_indices, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SetEncodingOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.set_encoding"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def set_encoding(result, source, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(SetEncodingOp(result=result, source=source, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class SortOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.sort"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, outputs, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    issubclass(type(dimension), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self):
    return self.regions[0]

def sort(results_, inputs, outputs, dimension, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(SortOp(results_=results_, inputs=inputs, outputs=outputs, dimension=dimension, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class TopkOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.topk"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (1, True)

  def __init__(self, results_, inputs, outputs, dimension, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["dimension"] = (dimension if (
    issubclass(type(dimension), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(dimension, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def dimension(self):
    return self.operation.attributes["dimension"]

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

  @builtins.property
  def region(self):
    return self.regions[0]

def topk(results_, inputs, outputs, dimension, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(TopkOp(results_=results_, inputs=inputs, outputs=outputs, dimension=dimension, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class UnPackOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.unpack"

  _ODS_OPERAND_SEGMENTS = [-1,-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, inputs, outputs, inner_tiles, static_inner_tiles, *, outer_dims_perm=None, inner_dims_pos=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    operands.append(_get_op_results_or_values(inner_tiles))
    _ods_context = _ods_get_default_loc_context(loc)
    if outer_dims_perm is not None: attributes["outer_dims_perm"] = (outer_dims_perm if (
        issubclass(type(outer_dims_perm), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(outer_dims_perm, context=_ods_context))
    if inner_dims_pos is not None: attributes["inner_dims_pos"] = (inner_dims_pos if (
        issubclass(type(inner_dims_pos), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(inner_dims_pos, context=_ods_context))
    attributes["static_inner_tiles"] = (static_inner_tiles if (
    issubclass(type(static_inner_tiles), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(static_inner_tiles, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def inner_tiles(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 2)
    return operand_range

  @builtins.property
  def outer_dims_perm(self):
    if "outer_dims_perm" not in self.operation.attributes:
      return None
    return self.operation.attributes["outer_dims_perm"]

  @outer_dims_perm.setter
  def outer_dims_perm(self, value):
    if value is not None:
      self.operation.attributes["outer_dims_perm"] = value
    elif "outer_dims_perm" in self.operation.attributes:
      del self.operation.attributes["outer_dims_perm"]

  @outer_dims_perm.deleter
  def outer_dims_perm(self):
    del self.operation.attributes["outer_dims_perm"]

  @builtins.property
  def inner_dims_pos(self):
    return self.operation.attributes["inner_dims_pos"]

  @inner_dims_pos.setter
  def inner_dims_pos(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["inner_dims_pos"] = value

  @builtins.property
  def static_inner_tiles(self):
    return self.operation.attributes["static_inner_tiles"]

  @static_inner_tiles.setter
  def static_inner_tiles(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_inner_tiles"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def unpack(results_, inputs, outputs, inner_tiles, static_inner_tiles, *, outer_dims_perm=None, inner_dims_pos=None, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(UnPackOp(results_=results_, inputs=inputs, outputs=outputs, inner_tiles=inner_tiles, static_inner_tiles=static_inner_tiles, outer_dims_perm=outer_dims_perm, inner_dims_pos=inner_dims_pos, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class UnsetEncodingOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.unset_encoding"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, source, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(source))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def source(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def unset_encoding(result, source, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(UnsetEncodingOp(result=result, source=source, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class UpperBoundTileSizeOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.upper_bound_tile_size"

  _ODS_REGIONS = (0, True)

  def __init__(self, results_, tensorType, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["tensorType"] = (tensorType if (
    issubclass(type(tensorType), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('anonymous_436')) else
      _ods_ir.AttrBuilder.get('anonymous_436')(tensorType, context=_ods_context))
    results.extend(results_)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def tensorType(self):
    return self.operation.attributes["tensorType"]

  @tensorType.setter
  def tensorType(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["tensorType"] = value

  @builtins.property
  def results_(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def upper_bound_tile_size(results_, tensor_type, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(UpperBoundTileSizeOp(results_=results_, tensorType=tensor_type, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class WinogradInputTransformOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.winograd.input_transform"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, outputs, output_tile_size, kernel_size, image_dimensions, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["output_tile_size"] = (output_tile_size if (
    issubclass(type(output_tile_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_tile_size, context=_ods_context))
    attributes["kernel_size"] = (kernel_size if (
    issubclass(type(kernel_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(kernel_size, context=_ods_context))
    attributes["image_dimensions"] = (image_dimensions if (
    issubclass(type(image_dimensions), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(image_dimensions, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def output_tile_size(self):
    return self.operation.attributes["output_tile_size"]

  @output_tile_size.setter
  def output_tile_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_tile_size"] = value

  @builtins.property
  def kernel_size(self):
    return self.operation.attributes["kernel_size"]

  @kernel_size.setter
  def kernel_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_size"] = value

  @builtins.property
  def image_dimensions(self):
    return self.operation.attributes["image_dimensions"]

  @image_dimensions.setter
  def image_dimensions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["image_dimensions"] = value

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def winograd_input_transform(result, inputs, outputs, output_tile_size, kernel_size, image_dimensions, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(WinogradInputTransformOp(result=result, inputs=inputs, outputs=outputs, output_tile_size=output_tile_size, kernel_size=kernel_size, image_dimensions=image_dimensions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class WinogradOutputTransformOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.winograd.output_transform"

  _ODS_OPERAND_SEGMENTS = [-1,-1,]

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, outputs, output_tile_size, kernel_size, image_dimensions, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_results_or_values(inputs))
    operands.append(_get_op_results_or_values(outputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["output_tile_size"] = (output_tile_size if (
    issubclass(type(output_tile_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(output_tile_size, context=_ods_context))
    attributes["kernel_size"] = (kernel_size if (
    issubclass(type(kernel_size), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(kernel_size, context=_ods_context))
    attributes["image_dimensions"] = (image_dimensions if (
    issubclass(type(image_dimensions), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('DenseI64ArrayAttr')) else
      _ods_ir.AttrBuilder.get('DenseI64ArrayAttr')(image_dimensions, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 0)
    return operand_range

  @builtins.property
  def outputs(self):
    operand_range = _ods_segmented_accessor(
         self.operation.operands,
         self.operation.attributes["operandSegmentSizes"], 1)
    return operand_range

  @builtins.property
  def output_tile_size(self):
    return self.operation.attributes["output_tile_size"]

  @output_tile_size.setter
  def output_tile_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["output_tile_size"] = value

  @builtins.property
  def kernel_size(self):
    return self.operation.attributes["kernel_size"]

  @kernel_size.setter
  def kernel_size(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["kernel_size"] = value

  @builtins.property
  def image_dimensions(self):
    return self.operation.attributes["image_dimensions"]

  @image_dimensions.setter
  def image_dimensions(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["image_dimensions"] = value

  @builtins.property
  def result(self):
    _ods_variadic_group_length = len(self.operation.results) - 1 + 1
    return self.operation.results[0:0 + _ods_variadic_group_length]

def winograd_output_transform(result, inputs, outputs, output_tile_size, kernel_size, image_dimensions, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(WinogradOutputTransformOp(result=result, inputs=inputs, outputs=outputs, output_tile_size=output_tile_size, kernel_size=kernel_size, image_dimensions=image_dimensions, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class YieldOp(_ods_ir.OpView):
  OPERATION_NAME = "iree_linalg_ext.yield"

  _ODS_REGIONS = (0, True)

  def __init__(self, operands_, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(operands_))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def operands_(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

def yield_(operands_, *, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(YieldOp(operands_=operands_, loc=loc, ip=ip))
