\chapter{KTH Forms}

We want to access data from forms in KTH Forms.
For example, Restlabb records student results in KTH Forms.
It would be nice to easily extract those data.
Forms can export data in CSV format, this can easily be printed to stdout in 
the terminal for further processing.

In the long run we'd like to be able to list all the forms a user has access 
to, and use the actual names of the forms.
We also want to add shortcut names to the different forms for easy access.
For now, we simply add each form manually as such; and then print the contents 
of the desired form.


\section{Code overview}

This is an independent module in the [[kthutils]] package: [[kthutils.forms]].
It resides in the [[forms.py]] file.
Since we use [[typer]] we add one function per command as well as option and 
argument definitions for each command.
<<forms.py>>=
import typer
from typing import Annotated, Any, List, Tuple

<<imports>>

cli = typer.Typer(name="forms", help="Access KTH Forms")

<<API for KTH Forms>>

<<option and argument definitions>>
<<command definitions>>

def main():
  cli()

if __name__ == "__main__":
  main()
@

\subsection{Tests}

We add tests for the module in the [[test_forms.py]] file.
<<test forms.py>>=
import pytest
import kthutils.forms
<<test imports>>

<<test setup>>

<<test functions>>
@


\section{Adding forms}

We add forms manually for now.
So we add a command for adding a form.
<<add command doc>>=
Adds a form to the configuration
<<command definitions>>=
@cli.command(name="add")
def cli_add_form(<<args for add command>>):
  """
  <<add command doc>>
  """
  <<add the form>>
@

We want to add the each form to a dictionary in the configuration:
a name and a URL.
<<args for add command>>=
name: Annotated[FormName, form_name_arg],
url: Annotated[str, form_url_arg]
@

The form name must not contain any periods (dots), due to how the config system 
of [[typerconf]] works.
Consequently, we add a custom parser for the form name which rejects any names 
containing periods by raising a [[typer.BadParameter]] exception.

Since we inherit from [[str]] we must use the [[__new__]] method to create the 
instance.
We can't use [[__init__]] since [[str]] is immutable, and [[__init__]] is 
called after the instance is created.
(It follows that [[__new__]] is a class method, not an instance method.)
<<option and argument definitions>>=
class FormName(str):
  def __new__(cls, value):
    if "." in value:
      raise typer.BadParameter("Name cannot contain '.'")
    return super().__new__(cls, value)

form_name_arg = typer.Argument(help="Name of the form",
                               parser=FormName,
                               autocompletion=get_added_forms)
form_url_arg = typer.Argument(help="URL to the form. This can be any public "
                                   "URL that results in a CSV file. But it "
                                   "automatically logs in for KTH Forms.")
<<imports>>=
import typerconf
<<add the form>>=
typerconf.set(f"forms.{name}", url)
@

\subsection{Listing all added forms}

We want to list all the forms we've added.
This is useful for autocompletion if we add a parameter for filtering based on 
prefix.
<<API for KTH Forms>>=
def get_added_forms(prefix: str = "") -> List[str]:
  """
  Returns a list of all the forms added to the configuration that are prefixed 
  by `prefix`. Default prefix is an empty string, which returns all forms.
  """
  forms = typerconf.get("forms").keys()
  return list(filter(lambda x: x.startswith(prefix), forms))
@


\section{An API for KTH Forms}

Since we must be logged in to access KTH Forms, we want to create a class for 
using.
This class will in turn use the [[weblogin]] package.
<<API for KTH Forms>>=
class FormsSession:
  """
  Maintains a session to the KTH Forms service.
  """

  BASE_URL = <<KTH Forms base URL>>

  def __init__(self, username: str, password: str):
    """
    Creates a new session to the KTH Forms service.

    `username` is the KTH username to use for logging in through 
    https://login.ug.kth.se. `password` is the password to use for logging in.
    """
    <<Forms constructor>>

  <<Forms methods>>
@

Now we can create a session to use for testing.
<<test setup>>=
forms = kthutils.forms.FormsSession(*kthutils.credentials.get_credentials())
<<test imports>>=
import kthutils.credentials
import os
@


\subsection{Logging in}

To trigger the login we must have the correct URL.
<<KTH Forms base URL>>=
"https://www.kth.se/form/admin"
@

We can then create a session using [[weblogin]].
<<Forms constructor>>=
self.__session = weblogin.AutologinSession([
                      weblogin.kth.UGlogin(username, password,
                                           self.BASE_URL)
                    ])
<<imports>>=
import weblogin
import weblogin.kth
@


\subsection{Getting a form}

For now, we'll add a method for getting a form by URL.
It will return a CSV reader for the form.
<<imports>>=
import csv
<<Forms methods>>=
def get_data_by_url(self, url: str) -> Tuple[bytes, str]:
  """
  Gets the form at the given URL and returns it as (content, type) tuple. 
  Content is the raw data of the form, type is the content type of the form.
  """
  response = self.__session.get(url)
  if response.status_code != requests.codes.ok:
    raise ValueError(f"Failed to get form at {url}: {response.text}")

  return response.content, response.headers["Content-Type"]
<<imports>>=
import requests
@

We can test this with a known form.
<<test functions>>=
def test_get_data_by_url():
  data, content_type = forms.get_data_by_url(
      "https://www.kth.se/form/admin/api/webform/64ec8baa917ea4c31c33267e/answer/export")
  assert content_type == "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
  assert data.startswith(b"PK")
@

\subsection{Getting a form in CSV format}

We can add a method for getting a form in CSV format, that is a list of lists 
as would be returned by the [[csv.reader]].
<<Forms methods>>=
def get_csv_by_url(self, url: str) -> List[List[str]]:
  """
  Gets the form at the given URL and returns it as a list of lists.
  """
  data, content_type = self.get_data_by_url(url)

  <<process [[data]] into [[csvdata]]>>

  return list(csvdata)
@

We want to test this method as well.
We'll use the same form as before, this is the form for Restlabb 2023/2024.
The first column is \enquote{Svarsdatum} and the second is \enquote{Kurs}.
<<test functions>>=
def test_get_csv_by_url():
  csvdata = forms.get_csv_by_url(
      "https://www.kth.se/form/admin/api/webform/64ec8baa917ea4c31c33267e/answer/export")
  assert "Svarsdatum" in csvdata[0] and "Kurs" in csvdata[0]
@

\subsection{Processing the data to CSV}

The data we get can be in either CSV or XLS(X) format.
In the case of KTH Forms, it exports and XLSX file.
<<process [[data]] into [[csvdata]]>>=
if content_type == "text/csv":
  csvdata = csv.reader(data.decode("utf-8").splitlines())
elif "excel" in content_type or "spreadsheet" in content_type:
  <<transform XLSX [[data]] into [[csvdata]]>>
else:
  raise ValueError(f"Form at {url} is not in CSV nor XLS(X) format")
@

There is a key detail in the transformation of XLSX to CSV.
We use the [[openpyxl]] package to read the XLSX file.
Each row that [[openpyxl]] produces is a tuple of cell values, not a list!
The [[csv]] module, on the other hand, works with lists, not tuples.
Hence we must also transform each row into a list.
Another difference is that [[openpyxl]] uses [[None]] for empty cells, while 
[[csv]] uses an empty string.
We must fix this too.
<<transform XLSX [[data]] into [[csvdata]]>>=
datafile = io.BytesIO(data)
<<let [[wb]] contain the workbook of [[datafile]]>>
sheet = wb.active
fix_empty_cells = lambda x: list(map(lambda y: y if y is not None else "", x))
csvdata = map(fix_empty_cells, sheet.iter_rows(values_only=True))
<<imports>>=
import io
import openpyxl
@

Another annoyance with the [[openpyxl]] package is that it prints warnings when 
the file has no stylesheet information.
We're fine with this and there is no problem.
So when we read, we'll turn off the warnings.
<<let [[wb]] contain the workbook of [[datafile]]>>=
with warnings.catch_warnings():
  warnings.simplefilter("ignore")
  wb = openpyxl.load_workbook(datafile)
<<imports>>=
import warnings
@


\section{Exporting form data}

We want to export data from a form.
We add a command for this.
<<export command doc>>=
Prints data from a form to stdout in CSV format
<<command definitions>>=
@cli.command(name="export")
def cli_export_form(<<args for export command>>):
  """
  <<export command doc>>
  """
  <<export the form>>
@

We need a name for the form to export.
<<args for export command>>=
name: Annotated[FormName, form_name_arg],
@

We can then get the URL for the form from the configuration and use the 
[[get_form_by_url]] method to get the form.
<<export the form>>=
<<let [[csvdata]] contain the form data>>
<<set up [[csvout]] as a CSV writer>>
<<print all rows in [[csvdata]]>>
@

To get the data, we first need the URL from the configuration.
Then we need the credentials to log into KTH Forms.
<<let [[csvdata]] contain the form data>>=
url = typerconf.get(f"forms.{name}")
forms = kthutils.forms.FormsSession(*kthutils.credentials.get_credentials())
csvdata = forms.get_csv_by_url(url)
<<imports>>=
import kthutils.credentials
@

We'll print the data as CSV data to stdout.
We'll let the user decide on the delimiter, but we'll default to tab.
<<set up [[csvout]] as a CSV writer>>=
csvout = csv.writer(sys.stdout, delimiter=delimiter)
<<args for export command>>=
delimiter: Annotated[str, delimiter_arg] = "\t",
<<option and argument definitions>>=
delimiter_arg = typer.Option(help="Delimiter to use for the CSV output")
<<imports>>=
import sys
<<print all rows in [[csvdata]]>>=
for row in csvdata:
  csvout.writerow(row)
@


\section{Turning a form into a generator}

We want to add the command [[next]] (in reference to Python generators) that 
essentially turns a form into a generator.
Whenever run it prints the new rows added to the form since the last time the 
command was run.
<<next command doc>>=
Prints new data from a form to stdout in CSV format
@

The command is very similar to the [[export]] command.
The only difference is the filtering.
<<command definitions>>=
@cli.command(name="next")
def cli_next_form(<<args for export command>>):
  """
  <<next command doc>>
  """
  <<set up [[csvout]] as a CSV writer>>
  <<let [[csvdata]] contain the form data>>
  <<filter [[csvdata]] to only contain new data>>
  <<print all rows in [[csvdata]]>>
@

To filter the data, we need to know what the export looked like the last time 
we ran the command.
We can store this in a file in the data directory.
Once we've computed the new data, we can store the current data in the file 
instead.
<<filter [[csvdata]] to only contain new data>>=
<<let [[prev_csvdata]] contain the previous form data>>
new_csvdata = csvdata.copy()
csvdata = list(filter(lambda x: x not in prev_csvdata, new_csvdata))
<<store [[new_csvdata]] as the previous form data>>
@

We use the [[dirs.user_data_dir]] function from [[typerconf]] to get the data 
directory.
Then we simply use a file [[next.csv]] to store the data.
If the file doesn't exist when reading, it's the first time we run [[next]] and 
we have an empty list.
<<let [[prev_csvdata]] contain the previous form data>>=
data_dir = pathlib.Path(typerconf.dirs.user_data_dir)
prev_csvdata = []
prev_csvfile = data_dir / "next.csv"
if prev_csvfile.exists():
  with prev_csvfile.open("r") as f:
    prev_csvdata = list(csv.reader(f))
<<imports>>=
import pathlib
<<store [[new_csvdata]] as the previous form data>>=
if not data_dir.exists():
  data_dir.mkdir(parents=True)
with prev_csvfile.open("w") as f:
  csv.writer(f).writerows(new_csvdata)
