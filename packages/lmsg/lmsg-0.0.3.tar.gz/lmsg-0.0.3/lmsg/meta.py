# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_meta.ipynb.

# %% auto 0
__all__ = ['MessageMeta']

# %% ../nbs/01_meta.ipynb 6
from inspect import isclass
from functools import wraps
from contextlib import contextmanager

# %% ../nbs/01_meta.ipynb 8
from typing import Self, Type, Optional, Callable

# %% ../nbs/01_meta.ipynb 10
#| export


# %% ../nbs/01_meta.ipynb 12
#| export


# %% ../nbs/01_meta.ipynb 14
from .type import P, M

# %% ../nbs/01_meta.ipynb 16
class MessageMeta(type):
    '''
    A metaclass for creating enhanced message classes suitable for structured logging.

    This metaclass enriches the message classes with additional functionalities such as conditional logging,
    decoration capabilities, and utility methods for streamlined logging processes.

    Methods
    -------
    __new__(mcls, name, bases, namespace):
        Constructs a new class instance. This method is invoked when a new class is created using the MessageMeta
        metaclass.

    __call__(cls, *args, **kwargs):
        Overrides the standard behavior when the class is instantiated. If used as a decorator, it applies
        additional functionalities to another class.

    decorate(cls, kls):
        A decorator method that adds message-related functionality (like logging) to the given class `kls`.

    make(cls):
        Creates a function that initializes and processes a message instance, applying conditional logging.

    context(cls, hush):
        A class method that serves as a context manager for temporarily setting the hush attribute for the class.

    Examples
    --------
    >>> class MyMessage(Message, metaclass=MessageMeta):
    >>>     pass

    >>> # Using MyMessage as a standard class
    >>> msg = MyMessage("A message", level=logging.INFO)
    >>> msg.log()

    >>> # Using MyMessage as a decorator
    >>> @MyMessage
    >>> def my_function():
    >>>     print("Function execution")

    >>> my_function()  # Logs message when function is called

    >>> # Using context manager to temporarily hush messages
    >>> with MyMessage.context(hush=True):
    >>>     msg = MyMessage("This message will be hushed")
    >>>     msg.log()  # This will not log due to hush being True

     Example of using `decorate` method
    >>> @MessageMeta.decorate
    >>> class CustomClass:
    >>>     def method(self):
    >>>         print("Method called")

    # Example of using `__call__` method
    >>> message_instance = Message("A log message")
    >>> message_instance.log()

    # Example of using `make` method
    >>> send_message = MessageMeta.make(Message)
    >>> send_message("Another log message")

    # Example of using `context` method
    >>> with MessageMeta.context(hush=True):
    >>>     muted_message = Message("This message will be hushed")
    >>>     muted_message.log()  # This message will not be logged    
    '''
    def __new__(mcls: Type[Self], name: str, bases: tuple[type, ...], namespace: dict) -> M:
        '''
        Called to create a new class instance.

        This method is automatically invoked when a new class is created using the MessageMeta metaclass.
        It sets up the class and can be used to modify the class's behavior.

        Parameters
        ----------
        mcls : Type[Self]
            The metaclass instance.
        name : str
            The name of the class being constructed.
        bases : tuple[type, ...]
            A tuple of the base classes the class is derived from.
        namespace : dict
            A namespace dictionary containing the class's attributes.

        Returns
        -------
        M
            A new class object with the given name, bases, and attributes.
        '''
        return super().__new__(mcls, name, bases, namespace)
    
    def __call__(cls: Type[Self], *args: P.args, **kwargs: P.kwargs) -> M:
        '''
        Overrides the normal behavior when the class is instantiated.

        This method is invoked when an attempt is made to instantiate classes of this metaclass.
        It can also be used as a decorator for another class, applying additional logging functionalities.

        Parameters
        ----------
        *args : P.args
            Positional arguments passed to the class.
        **kwargs : P.kwargs
            Keyword arguments passed to the class.

        Returns
        -------
        M
            An instance of the class or a modified class if used as a decorator.

        Examples
        --------
        # Example of using `__call__` method
        >>> message_instance = Message("A log message")
        >>> message_instance.log()
        '''
        # Detect if being used as a decorator
        if len(args) == 1 and isclass(args[0]):
            return cls.decorate(args[0])
        return super().__call__(*args, **kwargs)
    
    def decorate(cls: Type[Self], kls: M) -> M:
        '''
        A decorator method to add logging functionality to an existing class.

        When used as a decorator, this method wraps the provided class `kls` and enhances
        it with the logging functionality defined in the metaclass.

        Parameters
        ----------
        kls : M
            The class to be decorated with logging functionality.

        Returns
        -------
        M
            A new class that inherits from both the provided class `kls` and includes logging capabilities.

        Examples
        --------
        # Example of using `decorate` method
        >>> @MessageMeta.decorate
        >>> class CustomClass:
        >>>     def method(self):
        >>>         print("Method called")        
        '''
        @wraps(kls, updated=())
        class WrappedMessage(kls, cls):
            def __init__(self, *args, **kwargs):
                super().__init__(*args, **kwargs)
        return WrappedMessage
    
    def make(cls: Self) -> Callable:
        '''
        Creates a function that initializes and processes a message instance.

        This method returns a function that, when called, creates an instance of the message class,
        applies conditional logging based on the 'hush' attribute, and logs the message if applicable.

        Returns
        -------
        Callable
            A function that creates and processes a message instance based on the given arguments.

        Examples
        --------
        # Example of using `make` method
        >>> send_message = MessageMeta.make(Message)
        >>> send_message("Another log message")
        '''
        def send(*args: P.args, **kwargs: P.kwargs):            
            try:
                msg = cls(*args, **kwargs)
                if getattr(msg, 'hush', False): return 
                if getattr(msg, 'logger', False): msg.log()
                return msg
            except Exception:
                ...                
        return send
    
    @classmethod
    @contextmanager
    def context(cls, hush: Optional[bool] = None):
        '''
        A context manager for temporary modification of the hush attribute.

        This context manager temporarily sets the hush attribute for all instances of the class,
        allowing for conditional suppression of message logging within a specific code block.

        Parameters
        ----------
        hush : Optional[bool]
            The temporary hush value to be set for the duration of the context.

        Yields
        ------
        None

        Examples
        --------
        >>> with MessageMeta.context(hush=True):
        >>>     muted_message = Message("This message will be hushed")
        >>>     muted_message.log()  # This message will not be logged
        '''
        saved = cls.hush
        if hush is not None: cls.hush = hush
        try: yield
        finally: cls.hush = saved

# %% ../nbs/01_meta.ipynb 18
#| export
