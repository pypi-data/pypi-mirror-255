# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_base.ipynb.

# %% auto 0
__all__ = ['Message']

# %% ../nbs/02_base.ipynb 6
import sys, logging

# %% ../nbs/02_base.ipynb 8
from types import TracebackType
from typing import Self, Type, Optional, Mapping, IO

# %% ../nbs/02_base.ipynb 10
#| export

# %% ../nbs/02_base.ipynb 12
#| export

# %% ../nbs/02_base.ipynb 14
from .type import P, Level, SysExcInfoType
from .meta import MessageMeta

# %% ../nbs/02_base.ipynb 16
class Message(metaclass=MessageMeta):
    '''
    A base class for creating structured log messages.

    Instances of this class can be used for structured logging, with support for conditional logging,
    different log levels, and integration with Python's logging module.

    Attributes
    ----------
    msg : str
        The log message text.
    hush : bool
        Determines whether the log message should be suppressed.
    level : int
        The logging level (e.g., logging.INFO).
    extra : dict
        Extra key-value pairs to be added to the log message.

    Methods
    -------
    __init__(msg, *args, hush, level, **kwargs):
        Initializes a new instance of the Message class.

    hasmsg(), haslog(), haslvl(), hasfmt():
        Utility methods to check the presence of certain attributes.

    getmsg(msg), getlog(logger), getlvl(level), lvlstr(name), getout(level, out), getfmt(formatter):
        Methods to retrieve or set various logging-related attributes or defaults.

    lvlmap():
        Returns a mapping of log level names to their numeric values.

    reglvl(), regsys(logger, formatter):
        Registers a new logging level or system.
        
    getext(extra, **kwargs):
        Retrieves the extra key-value pairs for the log message.

    addkws(msg, **extras):
        Adds extra key-value pairs to the log message.

    stream(msg, level, out, sep, end, flush):
        Outputs the log message to a stream (stdout or stderr).

    __log__(logger, *args, exc_info, stack_info, stacklevel, extras, **kwargs):
        Logs the message using the Python logging system.

    __bool__():
        Returns True if the message is not hushed.

    call(*args, **kwargs):
        Calls the log method if the message is not hushed.

    log(*args, **kwargs):
        Logs the message, either using the logging system or a stream.

    __enter__(), __exit__(exc_type, exc_value, traceback):
        Context manager methods for using the message in a `with` statement.

    Notes
    -----
    The class also includes a destructor method to remove attached handlers.


    Examples
    --------
    >>> # Creating an instance of Message
    >>> log_msg = Message("Info message", level=logging.INFO)
    >>> log_msg.log()  # Logs the message
    ...    
    >>> # Using context manager to suppress logging
    >>> with Message("Debug message", level=logging.DEBUG, hush=True) as msg:
    >>>     msg.log()  # This message will not be logged due to hush being True
    ...
    >>> # Using utility methods
    >>> log_msg = Message("Warning message", level=logging.WARNING)
    >>> if log_msg.haslvl():
    >>>     print("Log level is set")
    ...
    >>> with Message(msg='Hello', hush=False) as msg:
    >>>     msg() # prints 'Hello'
    ...
    >>> with Message(msg='Hello', hush=True) as msg:
    >>>     msg() # nothing
    '''
    msg: str = ''    
    hush: bool = False,
    level: Level = logging.INFO
    extra: Mapping[str, object] = dict()
    def __init__(
        self, msg: str = '', *args: P.args, 
        hush: bool = False,
        name: Optional[str] = None, 
        level: Level = logging.INFO, 
        extra: Mapping[str, object] = dict(),
        logger: Optional[logging.Logger] = None, 
        formatter: Optional[logging.Formatter] = None,
        **kwargs: P.kwargs
    ):
        '''Initializes a new instance of the Message class.

        Parameters
        ----------
        msg : str
            The log message text.

        hush : bool, optional
            If True, the log message will be suppressed. Defaults to False.

        level : int, optional
            The logging level. Defaults to logging.INFO.
        
        extra : dict
            Extra key-value pairs to be added to the log message.

        *args : P.args
            Additional positional arguments.

        **kwargs : P.kwargs
            Additional keyword arguments.
        Examples
        --------
        >>> log_msg = Message("Sample log message", level=logging.INFO)
        >>> log_msg.log()
        '''
        super().__init__(*args, **kwargs)
        self.msg = msg
        self.hush = hush
        self.name = self.lvlstr(name)
        self.level = self.getlvl(level)
        self.extra = extra or dict()
        self.logger = self.getlog(logger)
        self.formatter = self.getfmt(formatter)
        self.reglvl(self.name, self.level)
        self.regsys(self.logger, self.formatter)

    def hasmsg(self: Self) -> bool:
        '''Checks if the message attribute is set.

        Returns
        -------
        bool
            True if the message attribute is set, False otherwise.

        Examples
        --------
        >>> log_msg = Message("Sample log message")
        >>> print(log_msg.hasmsg())  # Outputs: True
        '''
        return getattr(self, 'msg', False)
    
    
    def haslog(self: Self) -> bool:
        '''
        Checks if the logger attribute is set.

        Returns
        -------
        bool
            True if the logger attribute is set, False otherwise.

        Examples
        --------
        >>> log_msg = Message("Sample log message")
        >>> print(log_msg.haslog())  # Outputs: False if no logger is set
        '''
        return getattr(self, 'logger', False)
    
    
    def haslvl(self: Self) -> bool:
        '''
        Checks if a logging level is set for the message.

        Returns
        -------
        bool
            True if a logging level is set, False otherwise.

        Examples
        --------
        >>> log_msg = Message(level=logging.INFO)
        >>> print(log_msg.haslvl())  # Outputs: True
        '''
        return getattr(self, 'level', False)
    
    
    def hasfmt(self: Self) -> bool:
        '''
        Checks if a formatter is set for the message.

        Returns
        -------
        bool
            True if a formatter is set, False otherwise.

        Examples
        --------
        >>> log_msg = Message(formatter=my_custom_formatter)
        >>> print(log_msg.hasfmt())  # Outputs: True if a formatter is set
        '''
        return getattr(self, 'formatter', False)

    
    def getmsg(self: Self, msg: Optional[str] = None) -> str:
        '''
        Retrieves the message text, optionally replacing it with a provided message.

        Parameters
        ----------
        msg : Optional[str]
            A new message to replace the current one. If None or empty, the current message is used.

        Returns
        -------
        str
            The message text.

        Examples
        --------
        >>> log_msg = Message("Original message")
        >>> print(log_msg.getmsg("New message"))  # Outputs: 'New message'
        '''
        if msg is None or msg == '': return getattr(self, 'msg', '')
        return msg

    
    def getlog(self: Self, logger: Optional[logging.Logger] = None) -> logging.Logger:
        '''
        Retrieves the logger, or uses a provided logger.

        Parameters
        ----------
        logger : Optional[logging.Logger]
            A logger to be used. If None, the current logger is used.

        Returns
        -------
        logging.Logger
            The logger to be used for logging.

        Examples
        --------
        >>> log_msg = Message()
        >>> custom_logger = logging.getLogger("custom")
        >>> print(log_msg.getlog(custom_logger))  # Outputs: 'custom' logger object
        '''
        if logger is None: return getattr(self, 'logger', logging.getLogger())
        return logger
    
    
    def getlvl(self: Self, level: Optional[Level] = None) -> Level:
        '''
        Retrieves the logging level, or uses a provided level.

        Parameters
        ----------
        level : Optional[Level]
            A logging level to be used. If None, the current level is used.

        Returns
        -------
        Level
            The logging level.

        Examples
        --------
        >>> log_msg = Message(level=logging.INFO)
        >>> print(log_msg.getlvl(logging.DEBUG))  # Outputs: logging.DEBUG
        '''
        if level is None: return getattr(self, 'level', logging.INFO)
        return level
    
    
    def lvlstr(self: Self, name: Optional[str] = None) -> str:
        '''
        Retrieves the string representation of the logging level.

        Parameters
        ----------
        name : Optional[str]
            A name to be used for the level. If None, the class name is used.

        Returns
        -------
        str
            The string representation of the level.

        Examples
        --------
        >>> log_msg = Message(level=logging.WARNING)
        >>> print(log_msg.lvlstr())  # Outputs: 'WARNING'
        '''
        if name is None: name = getattr(self, 'name', type(self).__name__)
        return name
    
    
    def getout(self: Self, level: Optional[Level] = None, out: Optional[IO] = None) -> IO:
        '''
        Retrieves the appropriate output stream based on the logging level.

        Parameters
        ----------
        level : Optional[Level]
            The logging level to determine the output stream.
        out : Optional[IO]
            A specific output stream. If None, stdout or stderr is used based on the level.

        Returns
        -------
        IO
            The output stream (stdout or stderr).

        Examples
        --------
        >>> log_msg = Message(level=logging.ERROR)
        >>> print(log_msg.getout())  # Outputs: stderr
        '''
        err = logging.ERROR <= self.getlvl(level)
        if out is None: out = sys.stderr if err else sys.stdout
        return out        
    
    
    def getfmt(self: Self, formatter: Optional[logging.Formatter] = None) -> logging.Formatter:
        '''
        Retrieves the formatter, or uses a provided formatter.

        Parameters
        ----------
        formatter : Optional[logging.Formatter]
            A formatter to be used. If None, the current formatter is used.

        Returns
        -------
        logging.Formatter
            The formatter to be used for formatting log messages.

        Examples
        --------
        >>> custom_formatter = logging.Formatter('%(levelname)s - %(message)s')
        >>> log_msg = Message(formatter=custom_formatter)
        >>> print(log_msg.getfmt())  # Outputs: custom_formatter object
        '''
        if formatter is None: return getattr(self, 'formatter', logging.Formatter())
        return formatter
    
    
    def getext(self: Self, extra: Optional[Mapping[str, object]] = None, **kwargs) -> dict:
        attrs = getattr(self, 'extra', dict())
        extra = dict() if extra is None else extra
        extra = {**attrs, **extra, **kwargs} 
        return extra
    
    @classmethod
    def lvlmap(cls: Type[Self]) -> dict[str, int]:
        '''Returns a mapping of log level names to their numeric values.'''
        return logging.getLevelNamesMapping()
    
    
    @classmethod
    def reglvl(cls: Type[Self], name: Optional[str] = None, level: Optional[Level] = None) -> Type[Self]:
        '''Registers a new logging level based on the level attribute.

        This method adds a new logging level name to the logging system.

        Returns
        -------
        Message
            Returns self for chaining.

        Examples
        --------
        >>> log_msg = Message(level=42)
        >>> log_msg.reglvl()  # Registers level 42 with its name
        '''        
        if name is None: return
        if level is None: return
        lvl = cls.lvlmap().get(name, None)
        isreg = lvl != None and lvl == level
        if not isreg: logging.addLevelName(level, name)
        return cls
    
    @classmethod
    def regsys(
        cls: Type[Self], 
        logger: Optional[logging.Logger] = None, 
        formatter: Optional[logging.Formatter] = None,
    ) -> Type[Self]:
        '''
        Registers system logger and formatter.

        This method adds stream handlers for stdout and stderr to the logger.

        Parameters
        ----------
        logger : Optional[logging.Logger]
            The logger to which the handlers will be added. Defaults to the default logger.

        formatter : Optional[logging.Formatter]
            The formatter to be used by the handlers. Defaults to a basic formatter.

        Returns
        -------
        Message
            Returns self for chaining.

        Examples
        --------
        >>> log_msg = Message("Sample log message")
        >>> log_msg.regsys()  # Registers system logger and formatter
        '''
        if logger is None: return
        if getattr(cls, 'logger', None) is None: cls.logger = logger

        logger = cls.getlog(cls, logger)
        formatter = cls.getfmt(cls, formatter)

        # Add the stream handler to the logger
        stream = logging.StreamHandler(sys.stdout)
        stream.setFormatter(formatter)
        logger.addHandler(stream)
        
        stderr = logging.StreamHandler(sys.stderr)
        stderr.setLevel(logging.ERROR)
        stderr.setFormatter(formatter)
        logger.addHandler(stderr)

        if not hasattr(cls, '_handlers'): cls._handlers = (stream, stderr)
        else: cls._handlers += (stream, stderr)

        if getattr(cls, 'logger', None) is None: cls.logger = logger
        return cls
    
    def __del__(self) -> None:
        '''
        Destructor to clean up handlers attached to the logger.

        This method removes all handlers attached to the logger upon object deletion.

        Examples
        --------
        >>> log_msg = Message("Sample log message")
        >>> del log_msg  # Invokes the destructor to remove handlers
        '''
        handlers = getattr(self, '_handlers', getattr(type(self), '_handlers', None))
        if handlers is None: return
        for handler in handlers:
            self.getlog().removeHandler(handler)

    def addkws(self: Self, msg: Optional[str] = None, **extras: dict) -> str:
        '''
        Adds extra key-value pairs to the log message.

        Parameters
        ----------
        msg : Optional[str]
            The base message to which extras will be added.
        extras : dict
            Extra key-value pairs to be added to the message.

        Returns
        -------
        str
            The message with added key-value pairs.

        Examples
        --------
        >>> log_msg = Message("Sample log message")
        >>> updated_msg = log_msg.addkws(user='Alice', action='login')
        >>> print(updated_msg)  # Outputs: 'Sample log message\textras(user=Alice, action=login)'
        '''
        msg = self.getmsg(msg)
        ext = ', '.join(f'{k}={v}' for k, v in extras.items())
        if ext: msg += f'\textras({ext})'
        return msg

    def stream(
        self: Self, msg: str = '', *,
        level: Optional[Level] = None, out: Optional[IO] = None,
        sep: str = ' ', end: str = '\n', flush: bool = False, 
    ) -> Self:
        '''
        Outputs the message to a specified stream.

        Parameters
        ----------
        msg : str
            The message to be printed.
        level : Optional[Level]
            The logging level; used to determine the output stream if `out` is not provided.
        out : Optional[IO]
            The output stream (stdout or stderr).
        sep : str
            Separator between the message components.
        end : str
            The end character after the message.
        flush : bool
            Whether to forcibly flush the stream.

        Returns
        -------
        Message
            Returns self for chaining.

        Examples
        --------
        >>> log_msg = Message("Sample log message")
        >>> log_msg.stream()  # Prints the message to stdout or stderr based on level
        '''
        msg = self.getmsg(msg)
        out = self.getout(level, out)
        print(msg, sep=sep, end=end, flush=flush, file=out)
        return self
    
    def __log__(
        self: Self, logger: Optional[logging.Logger] = None, *args, 
        exc_info: SysExcInfoType = None, stack_info: bool = False, stacklevel: int = 1,
        extra: Mapping[str, object] = None, **kwargs
    ) -> Self:
        '''
        Logs the message using the Python logging system.

        Parameters
        ----------
        logger : Optional[logging.Logger]
            The logger to be used for logging.
        *args, **kwargs : Various
            Additional arguments passed to the logger.

        Returns
        -------
        Message
            Returns self for chaining.

        Examples
        --------
        >>> log_msg = Message("Sample log message")
        >>> log_msg.__log__()  # Logs the message using the default logger
        '''
        if (log := self.getlog(logger)) is None: return
        lvl = self.getlvl()
        msg = self.getmsg()
        
        extra = self.getext(extra, **kwargs)
        msg = self.addkws(**extra)
        log.log(lvl, msg, *args, exc_info=exc_info, stack_info=stack_info, stacklevel=stacklevel, extra=extra)
        return self

    def __bool__(self: Self) -> bool:
        '''
        Determines the truth value of the Message instance.

        Returns
        -------
        bool
            False if the message is hushed, True otherwise.

        Examples
        --------
        >>> log_msg = Message("Sample log message", hush=True)
        >>> print(bool(log_msg))  # Outputs: False
        '''
        return not getattr(self, 'hush', False)
    
    def __call__(self: Self, *args, **kwargs) -> Self:
        '''
        Calls the log method if the message is not hushed.

        Parameters
        ----------
        *args, **kwargs : Various
            Arguments to be passed to the log method.

        Returns
        -------
        Message
            Returns self for chaining.

        Examples
        --------
        >>> log_msg = Message("Sample log message")
        >>> log_msg.call()  # Logs the message if not hushed
        '''
        if self: self.log(*args, **kwargs)
        return self

    def log(self: Self, *args, **kwargs) -> Self:
        '''
        Logs the message using the configured logging system or stdout/stderr.

        If a logger is available and the message is not hushed, it logs the message using the Python logging system.
        Otherwise, it outputs the message to stdout or stderr.

        Examples
        --------
        >>> log_msg = Message("Error message", level=logging.ERROR)
        >>> log_msg.log()  # Logs the message at ERROR level
        '''
        if self.hush: return self
        if self.haslog(): self.__log__(*args, **kwargs)            
        else: self.stream(self.msg)
        return self
    
    def __enter__(self: Self) -> Self:
        '''
        Context manager entry method.

        Returns
        -------
        Message
            Returns self to allow usage in 'with' statements.

        Examples
        --------
        >>> with Message("Context manager message", level=logging.INFO) as log_msg:
        >>>     log_msg.log()  # Logs the message
        '''
        return self

    def __exit__(self: Self, exc_type: type, exc_value: Exception, traceback: TracebackType) -> bool:
        '''
        Context manager exit method.

        Parameters
        ----------
        exc_type : type
            The exception type if an exception was raised in the context.
        exc_value : Exception
            The exception instance if an exception was raised.
        traceback : TracebackType
            The traceback if an exception was raised.

        Returns
        -------
        bool
            Returns the hush attribute to indicate if exceptions should be suppressed.

        Examples
        --------
        >>> with Message("Context manager message", hush=True) as log_msg:
        >>>     raise ValueError("This exception will be suppressed")
        '''
        return self.hush

# %% ../nbs/02_base.ipynb 19
#| export
